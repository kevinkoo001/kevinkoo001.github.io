<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://kevinkoo001.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://kevinkoo001.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-09-25T07:15:52+00:00</updated><id>https://kevinkoo001.github.io/feed.xml</id><title type="html">Hyungjoon (Kevin) Koo</title><subtitle></subtitle><entry><title type="html">Compiler-assisted Code Randomization</title><link href="https://kevinkoo001.github.io/blog/2018/compiler-assisted-code-randomization/" rel="alternate" type="text/html" title="Compiler-assisted Code Randomization"/><published>2018-05-23T22:31:16+00:00</published><updated>2018-05-23T22:31:16+00:00</updated><id>https://kevinkoo001.github.io/blog/2018/compiler-assisted-code-randomization</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2018/compiler-assisted-code-randomization/"><![CDATA[<table cellpadding="0" cellspacing="0" border="0"><tbody><tr style="height: 145px;"> <td style="height: 145px;">I. Motivation II. Compiler-assisted Code Randomization (CCR) Overview III. Identifying Essential Information for Randomization IV. Obtaining Metadata from the LLVM Backend V. Metadata Definition with Google’s Protocol Buffers VI. Consolidating Metadata in the gold Linker VII. Randomizer  VIII. Evaluation </td></tr></tbody></table> <h4 id="i-motivation"><strong>I. Motivation</strong></h4> <hr/> <p><em><strong>Code randomization</strong></em> is not a new technique in the software security field. Rather, it is a well-known <em>defense against code reuse attack</em> (a.k.a <a href="https://en.wikipedia.org/wiki/Return-oriented_programming">return-oriented programming or ROP</a>) by breaking the assumption of the attackers that useful gadgets (arbitrary instruction snippets to choose from a potentially vulnerable process memory space) are available. One might argue the application with a scripting-enabled feature allows an adversary to have the power to scan the code segments on the fly (i.e., by leveraging a memory disclosure), rendering the defense invalid. Such a <em>just-in-time ROP</em> (dubbed <em>JIT-ROP</em>) could be prevented with the <em>execute-only</em> memory (<em>XOM</em>) concept by restriction of reading the code, which blocks the on-the-fly discovery of gadgets. Still the protection scheme is viable only upon diversified code as XOM would be pointless with the identical code page. (Note that here I use the following terms interchangeably: randomization, diversification, transformation, and shuffling.)</p> <p>However, modern operating systems have only adopted <em>address space layout randomization</em> (a.k.a <em>ASLR</em>) despite decades of research that shows <em><strong>software diversification</strong> _is an effective protection mechanism. If so, why would software vendors not offer the protection? I believe it is presumably because it seems non-trivial to generate a unique instance at each end.  Having explored previous works on binary transformation, I found two major requirements for widespread adoption: i) _<strong>reliable binary rewriting</strong></em> (one would not desire a broken executable to boost security) and ii) <em><strong>reasonable cost</strong></em> (creating hardened variants, distributing them and maintaining compatibility should not be costly). </p> <blockquote>Code Randomization is an effective protection scheme against code-reuse attack. However, it has not been deployed by software vendors mainly due to the difficulty of rewriting binary reliably at a reasonable cost. Can we tackle the hurdle if the pre-defined transformation-assisting information could be obtained from a compiler toolchain?</blockquote> <p>For (i), one observation is that traditional binary rewriting requires complicated binary analysis and/or disassembly process at all times to create a sane executable.  Although <strong><em>static binary analysis</em></strong> (without running binary) and <strong><em>dynamic binary analysis</em></strong> have their own advantages, even using both might be sometimes far from the ground truth. Likewise, heuristics have limitation to obtain a reliable binary with full accuracy. For example, it is quite hard to identify function boundary correctly when the code has been highly optimized (i.e., -O3) by compiler. For (ii), it is obvious that the vendors would be reluctant to create numerous copies (i.e., a popular application like a browser used by tens of millions of end users) and to store them through the current distribution channel (i.e., CDN; Content Delivery Network). It could be even worse when those variants become incompatible with patching, crash reporting and other mechanisms on software uniformity.</p> <p>The aforementioned hurdles had motivated me to hack a <em>toolchain</em> itself that is responsible for building the final executable. In other words, <em>compiler and linker should be able to explain every single byte to be emitted</em>, which eventually guarantees the perfect executable (all the time) to preserve the original semantics without running it. Hence, it would be feasible to rewrite a reliable variant without a cumbersome analysis <em><strong>if only if</strong></em> <strong><em>essential information for transformation could be extracted during compilation</em></strong>, which tackles the issue (i). The collected information allows one to generate his/her own instance <strong><em>on demand</em> <em>at installation time</em></strong> once the final executable contains the information, which resolves the issue (ii).</p> <h4 id="ii-compiler-assisted-code-randomization-ccr-overview"><strong>II. Compiler-assisted Code Randomization (CCR) Overview</strong></h4> <hr/> <p>Here introduces_<strong> Compiler-assisted Code Randomization (CCR),</strong><em> a hybrid method to enable practical and generic code transformation, which relies on _compiler-rewriter cooperation</em>. The approach allows end users to facilitate rapid and reliable fine-grained code randomization (at both a function level and a basic block level) on demand at installation time. The main concept behind CCR is <em><strong>to augment the final executable with a minimal (pre-defined) set of transformation-assisting metadata</strong></em>. Note that the <em>LLVM</em> and <em>gold</em> have been chosen as compiler and linker for CCR prototype. The following table briefly shows the essential information that could be collected/adjusted at compilation/linking time. [table id=3 /]</p> <p>The following figure illustrates the overview of the proposed approach from a high level at a glance. Once a modified compiler (LLVM) collects metadata for each object file upon given source code, the modified linker (gold) consolidates/updated the metadata and store it to the final executable. Once software vendor is ready for distributing a master binary, it is transferred to end users over legacy channel. A binary rewriter leverages the embedded metadata to produce the diversified instances of the executable. <a href="http://dandylife.net/blog/?attachment_id=888"><img src="http://dandylife.net/blog/wp-content/uploads/2018/05/overview-1.png" alt=""/></a></p> <blockquote>For interested readers, you may jump into my [git repository](https://github.com/kevinkoo001/CCR) to play with CCR before moving on. The README describes how to build it and how to instrument a binary in detail. Here is the paper: _[Compiler-assisted Code Randomization](http://dandylife.net/blog/wp-content/uploads/2018/05/ccr.sp18.pdf) in [Proceedings of the 39th IEEE Symposium on Security &amp; Privacy (S&amp;P)](https://www.computer.org/csdl/proceedings/sp/2018/4353/00/index.html)_. The slides are available [here](http://dandylife.net/blog/wp-content/uploads/2018/05/CCR_final.pdf).  &gt; &gt; </blockquote> <h4 id="iii-identifying-essential-information-for-randomization"><strong>III. Identifying Essential Information for Randomization</strong></h4> <hr/> <p>This chapter does not explain extensive metadata described above. Instead it will guide how to identify the crucial information for transformation. Let us investigate how the LLVM backend emits the final bytes with a very simple example. The following source code just calls a single function and exit.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// foo.c example
#include &lt;stdio.h&gt;

void foo(void);

int main(void) {
        foo();
        return 0;
}

void foo() {
        printf("foo called!\n");
}
</code></pre></div></div> <p>The LLVM itself (compiled with a debugging option -g) allows us to use fine grained debug information with <em>DEBUG_TYPE</em> and <em>-debug-only</em> option (<a href="http://llvm.org/docs/ProgrammersManual.html#the-debug-macro-and-debug-option">See the programmers manual in the LLVM</a>). Using the following compilation options, you could see what’s happening inside the LLVM backend.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang3 -o foo -mllvm -debug-only=mc-dump foo.c
... (omitted)
assembler backend - final-layout
--
&lt;MCAssembler
  Sections:[
    &lt;MCSection Fragments:[
      &lt;MCAlignFragment&lt;MCFragment 0xac7b7f0 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0&gt; (emit nops)
        Alignment:4 Value:0 ValueSize:1 MaxBytesToEmit:4&gt;&gt;,
      &lt;MCAlignFragment&lt;MCFragment 0xaca6b50 LayoutOrder:1 Offset:0 HasInstructions:0 BundlePadding:0&gt; (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16&gt;&gt;,
      &lt;MCDataFragment&lt;MCFragment 0xaca6e50 LayoutOrder:2 Offset:0 HasInstructions:1 BundlePadding:0&gt;
        Contents:[55,48,89,E5,48,83,EC,10,C7,45,FC,00,00,00,00,E8,00,00,00,00,31,C0,48,83,C4,10,5D,C3] (28 bytes),
        Fixups:[&lt;MCFixup Offset:16 Value:foo-4 Kind:6&gt;]&gt;,
      &lt;MCAlignFragment&lt;MCFragment 0xac938c0 LayoutOrder:3 Offset:28 HasInstructions:0 BundlePadding:0&gt; (emit nops)
        Alignment:16 Value:0 ValueSize:1 MaxBytesToEmit:16&gt;&gt;,
      &lt;MCDataFragment&lt;MCFragment 0xaca8be0 LayoutOrder:4 Offset:32 HasInstructions:1 BundlePadding:0&gt;
        Contents:[55,48,89,E5,48,83,EC,10,48,BF,00,00,00,00,00,00,00,00,B0,00,E8,00,00,00,00,89,45,FC,48,83,C4,10,5D,C3] (34 bytes),
        Fixups:[&lt;MCFixup Offset:10 Value:.L.str Kind:3&gt;,
                &lt;MCFixup Offset:21 Value:printf-4 Kind:6&gt;]&gt;]&gt;,
    &lt;MCSection Fragments:[
      &lt;MCDataFragment&lt;MCFragment 0xac92a60 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0&gt;
        Contents:[66,6F,6F,20,63,61,6C,6C,65,64,21,0A,00] (13 bytes)&gt;]&gt;,
    &lt;MCSection Fragments:[
      &lt;MCDataFragment&lt;MCFragment 0xac92650 LayoutOrder:0 Offset:0 HasInstructions:0 BundlePadding:0&gt;
        Contents:[00,63,6C,61,6E,67,20,76,65,72,73,69,6F,6E,20,33,2E,39,2E,30,20,28,74,61,67,73,2F,52,45,4C,45,41,53,45,5F,33,39,30,2F,66,69,6E,61,6C,29,00] (46 bytes)&gt;]&gt;,
... (omitted)
</code></pre></div></div> <p>The output shows the final layout determined by the LLVM assembler. At first, the jargon seems unfamiliar but we know what the sections are in a ELF format. The line 7, 21 and 24 tell us the beginning of the section. Now let’s see the section headers with a readelf utility.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ readelf -SW foo
There are 32 section headers, starting at offset 0x1a80:

Section Headers:
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        0000000000400238 000238 00001c 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            0000000000400254 000254 000020 00   A  0   0  4
  [ 3] .dynsym           DYNSYM          0000000000400278 000278 0000a8 18   A  4   1  8
  [ 4] .dynstr           STRTAB          0000000000400320 000320 000089 00   A  0   0  1
  [ 5] .gnu.hash         GNU_HASH        00000000004003b0 0003b0 00001c 00   A  3   0  8
  [ 6] .gnu.version      VERSYM          00000000004003cc 0003cc 00000e 02   A  3   0  2
  [ 7] .gnu.version_r    VERNEED         00000000004003dc 0003dc 000020 00   A  4   1  4
  [ 8] .rela.dyn         RELA            0000000000400400 000400 000018 18   A  3   0  8
  [ 9] .rela.plt         RELA            0000000000400418 000418 000048 18  AI  3  22  8
  [10] .init             PROGBITS        0000000000400460 000460 00001a 00  AX  0   0  4
  [11] .plt              PROGBITS        0000000000400480 000480 000040 10  AX  0   0 16
  [12] .text             PROGBITS        00000000004004c0 0004c0 0001c2 00  AX  0   0 16
  [13] .fini             PROGBITS        0000000000400684 000684 000009 00  AX  0   0  4
  [14] .rodata           PROGBITS        0000000000400690 000690 000011 00 AMS  0   0  4
  [15] .eh_frame         PROGBITS        00000000004006a8 0006a8 000114 00   A  0   0  8
  [16] .eh_frame_hdr     PROGBITS        00000000004007bc 0007bc 00003c 00   A  0   0  4
  [17] .jcr              PROGBITS        0000000000401df8 000df8 000008 00  WA  0   0  8
  [18] .fini_array       FINI_ARRAY      0000000000401e00 000e00 000008 00  WA  0   0  8
  [19] .init_array       INIT_ARRAY      0000000000401e08 000e08 000008 00  WA  0   0  8
  [20] .dynamic          DYNAMIC         0000000000401e10 000e10 0001d0 10  WA  4   0  8
  [21] .got              PROGBITS        0000000000401fe0 000fe0 000008 00  WA  0   0  8
  [22] .got.plt          PROGBITS        0000000000401fe8 000fe8 000030 00  WA  0   0  8
  [23] .data             PROGBITS        0000000000402018 001018 000010 00  WA  0   0  8
  [24] .tm_clone_table   PROGBITS        0000000000402028 001028 000000 00  WA  0   0  8
  [25] .bss              NOBITS          0000000000402028 001028 000001 00  WA  0   0  1
  [26] .comment          PROGBITS        0000000000000000 001028 000062 01  MS  0   0  1
  [27] .note.gnu.gold-version NOTE            0000000000000000 00108c 00001c 00      0   0  4
  [28] .rand             PROGBITS        0000000000000000 0010a8 00005f 00      0   0  1
  [29] .shstrtab         STRTAB          0000000000000000 00195b 000122 00      0   0  1
  [30] .symtab           SYMTAB          0000000000000000 001108 000660 18     31  49  8
  [31] .strtab           STRTAB          0000000000000000 001768 0001f3 00      0   0  1
</code></pre></div></div> <p>And here is part of disassembly in a .text section.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ objdump -dj.text -M intel foo | grep -A25 "&lt;main"
00000000004005c0 &lt;main&gt;:
  4005c0:       55                      push   rbp
  4005c1:       48 89 e5                mov    rbp,rsp
  4005c4:       48 83 ec 10             sub    rsp,0x10
  4005c8:       c7 45 fc 00 00 00 00    mov    DWORD PTR [rbp-0x4],0x0
  4005cf:       e8 0c 00 00 00          call   4005e0 &lt;foo&gt;
  4005d4:       31 c0                   xor    eax,eax
  4005d6:       48 83 c4 10             add    rsp,0x10
  4005da:       5d                      pop    rbp
  4005db:       c3                      ret
  4005dc:       0f 1f 40 00             nop    DWORD PTR [rax+0x0]

00000000004005e0 &lt;foo&gt;:
  4005e0:       55                      push   rbp
  4005e1:       48 89 e5                mov    rbp,rsp
  4005e4:       48 83 ec 10             sub    rsp,0x10
  4005e8:       48 bf 94 06 40 00 00    movabs rdi,0x400694
                00 00 00
  4005f2:       b0 00                   mov    al,0x0
  4005f4:       e8 b7 fe ff ff          call   4004b0 &lt;printf@plt&gt;
  4005f9:       89 45 fc                mov    DWORD PTR [rbp-0x4],eax
  4005fc:       48 83 c4 10             add    rsp,0x10
  400600:       5d                      pop    rbp
  400601:       c3                      ret
  400602:       66 66 66 66 66 2e 0f    nop WORD PTR cs:[rax+rax*1+0x0]
                1f 84 00 00 00 00 00
</code></pre></div></div> <p>Having a careful look, we could figure out the content of the <strong>MCDataFragment</strong> at line 13 in the mc-dump output contains multiple instructions (28 bytes in size) in the .text section (from 0x4005c0 to 0x4005db) of the <em>foo</em> executable. As you see, the first <strong>MCSection</strong> definitely represents the .text section.  The next fragment is <strong>MCAlignFragment</strong>, which is a 4-byte NOP instruction, followed by another MCDataFragment<strong><em> </em></strong>- that is a 34-byte foo() function (from 0x4005e0 to 0x400601). However, interestingly a 14-byte NOP instruction (or alignment) in the foo(), the LLVM backend does not have a corresponding MCAlignFragment. Where does it come from? A good guess is it might be generated by linker because it is the end of our object file, foo.o. Hence we need to explore what those fragments are to get the exact bytes to be emitted by the LLVM backend.</p> <p>Another point is that each MCDataFragment has (one or more) <strong>MCFixup</strong>. A <em><strong>fixup</strong></em> represents a placeholder that requires to be recalculated as further compilation process moves on. That is why all placeholders are initially marked as 0s. The fixup could be resolved either at link time or at load time. The latter is often referred to as a <em><strong>relocation</strong></em>. In order to avoid the confusion of the term, we explicitly refer to a relocation in an object file as a <em><strong>link-time relocation</strong></em> (which the linker handles), and a relocation in an executable as a <em><strong>load-time relocation</strong></em> (which the dynamic linker or loader handles). As an example, the yellow-colored lines above show one link-time relocation (line 18; the value ends up with 0x400694) and one load-time relocation (line 21; the final value is 0xfffffeb7). To summarize, <em>load-time relocations are a subset of link-time relocations, which are a subset of entire fixups</em>. It is obvious that we need the whole fixups for further fine-grained randomization, which cannot be obtained from relocations or even debugging information because the a resolved fixup is no longer available. Of course most fixups could be reconstructed with binary analysis and disassembly, however we want to avoid them possibly because of incompleteness and inaccuracy.</p> <p>One interesting observation is that a fixup even could be resolved by the assembler itself at compilation time. In particular, it finalizes the placeholder value during the _<strong>relaxation</strong> _phase (Eli wrote a nice article about it <a href="https://eli.thegreenplace.net/2013/01/03/assembler-relaxation">here</a>). The line 7 (0xc as the final value) is a good instance of the fixup that has been resolved by the assembler. In this case, the call instruction refers to the function foo() that is 12 bytes away (0x4005d4 + 0xc = 0x4005e0). Based on these fixup examples, we could deduce that a fixup information has three important attributes to update it during transformation properly: a) the location of the fixup, b) the size of the fixup to be de-referenced, and c) the fixup kind: either absolute or relative value. The fixups information is essential because they should be updated as code moves around.</p> <p>The second MCSection consists of a single MCDataFragment (13 bytes). It is part of .rodata section (0x666f6f20…) at 0x400690. Again, the preceded value 0x01000200 must be somehow created by the linker.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ readelf -x .rodata foo
Hex dump of section '.rodata':
  0x00400690 01000200 666f6f20 63616c6c 6564210a ....foo called!.
  0x004006a0 00                                  .
</code></pre></div></div> <p>The -M option offers the linker map about how each section has been linked. By passing that option to the gold, we could see a clear view of memory map.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang3 -v -o foo -Wl,-M foo.c
clang version 3.9.0 (tags/RELEASE_390/final)
... (omitted)
 "/usr/bin/ld" -z relro --hash-style=gnu --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o foo /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../x86_64-linux-gnu/crt1.o /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../x86_64-linux-gnu/crti.o /usr/lib/gcc/x86_64-linux-gnu/5.4.0/crtbegin.o -L/usr/lib/gcc/x86_64-linux-gnu/5.4.0 -L/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../x86_64-linux-gnu -L/lib/x86_64-linux-gnu -L/lib/../lib64 -L/usr/lib/x86_64-linux-gnu -L/usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../.. -L/home/kevinkoo001/Repos/antibloater/llvm-3.9.0/build/bin/../lib -L/lib -L/usr/lib -M /tmp/foo-e3c105.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/5.4.0/crtend.o /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../x86_64-linux-gnu/crtn.o
Archive member included because of file (symbol)

/usr/lib/x86_64-linux-gnu/libc_nonshared.a(elf-init.oS)
                              /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../x86_64-linux-gnu/crt1.o (__libc_csu_init)
... (omitted)
Memory map
... (omitted)
.text           0x00000000004004c0      0x1c2
 .text.unlikely
                0x00000000004004c0        0x0 /usr/lib/gcc/x86_64-linux-gnu/5.4.0/crtbegin.o
 .text.unlikely
                0x00000000004004c0        0x0 /usr/lib/x86_64-linux-gnu/libc_nonshared.a(elf-init.oS)
 .text          0x00000000004004c0       0x2a /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../x86_64-linux-gnu/crt1.o
                0x00000000004004c0                _start
 .text          0x00000000004004ea        0x0 /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../x86_64-linux-gnu/crti.o
 ** fill        0x00000000004004ea        0x6
 .text          0x00000000004004f0       0xc6 /usr/lib/gcc/x86_64-linux-gnu/5.4.0/crtbegin.o
 ** fill        0x00000000004005b6        0xa
 .text          0x00000000004005c0       0x42 /tmp/foo-e3c105.o
                0x00000000004005e0                foo
                0x00000000004005c0                main
 ** fill        0x0000000000400602        0xe
 .text          0x0000000000400610       0x72 /usr/lib/x86_64-linux-gnu/libc_nonshared.a(elf-init.oS)
                0x0000000000400610                __libc_csu_init
                0x0000000000400680                __libc_csu_fini
 .text          0x0000000000400682        0x0 /usr/lib/gcc/x86_64-linux-gnu/5.4.0/crtend.o
 .text          0x0000000000400682        0x0 /usr/lib/gcc/x86_64-linux-gnu/5.4.0/../../../x86_64-linux-gnu/crtn.o
... (omitted)
.rodata         0x0000000000400690       0x11
 ** merge constants
                0x0000000000400690        0x4
 ** merge strings
                0x0000000000400694        0xd
... (omitted)
</code></pre></div></div> <p>The .text section contains user-defined executable code as well as CRT (C Runtime) code. The line 23-25 explains how foo.c code layout has been formed.  Surprisingly, the line 26 (** fill) shows a 14-byte-long alignment that has not been emitted by the LLVM assembler. Likewise, the .rodata section has 4-byte constants (generated by gold), followed by the strings we saw (i.e., foo called!). For more information on how linker works, David wrote a good article <a href="http://www.lurklurk.org/linkers/linkers.html">here</a>. </p> <p>Now let’s take another example that contains function pointers.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// gate.c example
#include &lt;stdio.h&gt;

#define SUCCESS "Key success!"
#define FAIL    "Key failed!"
#define EASTEGG "Eastegg!"
#define GUEST   "Accepted as a guest!"

void success(int n) { printf("%s %d\n", SUCCESS, n); }
void fail(int n) { printf("%s %d\n", FAIL, n); }
void eastegg(int n) { printf("%s %d\n", EASTEGG, n); }
void guest(int n) { printf("%s %d\n", GUEST, n); }
void (*gate[4])(int) = {success, fail, eastegg, guest};

int main(int argc, char** argv) {
  if (argc &lt; 2 || argc &gt; 2) {
    printf("Usage: %s number to call a function\n", argv[0]);
    return -1;
  }

  int num = atoi(argv[1]);

  if (num &gt;= 0 &amp;&amp; num &lt; 4) {
    (*gate[num])(num);
  }

  else {
    printf("You should provide number between 0 and 4\n");
    return -1;
  }

  return 0;
}
</code></pre></div></div> <p>The line 13 has four function pointers that call different functions depending on the variable num. As seen, we could examine the emitted code in the same fashion, but this time focus on how to call one of the function pointers (stored in the variable gate) determined at runtime. Let’s debug the program with a gdb debugger and a <a href="https://github.com/longld/peda">peda plugin</a>. </p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb-peda$ b gate.c:23
Breakpoint 1 at 0x400777: file gate.c, line 23.
gdb-peda$ r 3
...(omitted)
[-------------------------------------code-----------------------------------]
   0x400767 &lt;main+103&gt;: jl     0x40078d &lt;main+141&gt;
   0x40076d &lt;main+109&gt;: cmp    DWORD PTR [rbp-0x14],0x4
   0x400771 &lt;main+113&gt;: jge    0x40078d &lt;main+141&gt;
=&gt; 0x400777 &lt;main+119&gt;: movsxd rax,DWORD PTR [rbp-0x14]
   0x40077b &lt;main+123&gt;: mov    rax,QWORD PTR [rax*8+0x402030]
   0x400783 &lt;main+131&gt;: mov    edi,DWORD PTR [rbp-0x14]
   0x400786 &lt;main+134&gt;: call   rax
   0x400788 &lt;main+136&gt;: jmp    0x4007ad &lt;main+173&gt;
[------------------------------------stack-----------------------------------]
0000| 0x7fffffffe120 --&gt; 0x4007c0 (&lt;__libc_csu_init&gt;:   push   r15)
0008| 0x7fffffffe128 --&gt; 0x300400500
0016| 0x7fffffffe130 --&gt; 0x7fffffffe228 --&gt; 0x7fffffffe48b ("~/Tmp/blog/gate")
0024| 0x7fffffffe138 --&gt; 0x2
0032| 0x7fffffffe140 --&gt; 0x4007c0 (&lt;__libc_csu_init&gt;:   push   r15)
0040| 0x7fffffffe148 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:       mov    edi,eax)
0048| 0x7fffffffe150 --&gt; 0x0
0056| 0x7fffffffe158 --&gt; 0x7fffffffe228 --&gt; 0x7fffffffe48b ("~/Tmp/blog/gate")
[----------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, main (argc=0x2, argv=0x7fffffffe228) at gate.c:23
23          (*gate[num])(num);
</code></pre></div></div> <p>Having a breakpoint at line 23 in the source, the yellow line 9-12 corresponds to call a function pointer (call rax) after setting up the register rax. The rax register holds the input value as a command line argument, and dereference the corresponding value in the function pointer table (located in 0x402030) at 0x40077b. Let’s check out what values are stored in that location.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ readelf -x .data gate
Hex dump of section '.data':
  0x00402020 00000000 00000000 00000000 00000000 ................
  0x00402030 00064000 00000000 40064000 00000000 ..@.....@.@.....
  0x00402040 80064000 00000000 c0064000 00000000 ..@.......@.....

$ readelf --syms gate | grep FUNC
...(omitted)
    74: 0000000000400680    53 FUNC    GLOBAL DEFAULT   12 eastegg
    75: 0000000000400640    53 FUNC    GLOBAL DEFAULT   12 fail
    77: 00000000004006c0    53 FUNC    GLOBAL DEFAULT   12 guest
    78: 0000000000400600    53 FUNC    GLOBAL DEFAULT   12 success
</code></pre></div></div> <p>As expected, four values reside in a .data section where each value points to four functions (success()@0x400600, fail@0x400640, eastegg@0x400680,  and guest@0x4006c0) to be referred. All these values are part of fixups, and now they could be within .data section as well as .text.</p> <p>In the same vein, the fixups could stay in a .rodata section as well. The next sample code contains a switch/case statement that generates a jump table as follow.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// switchcase.c example
#include &lt;stdio.h&gt;

void f0() { printf("f0 called\n"); }
void f1() { printf("f1 called\n"); }
void f2() { printf("f2 called\n"); }
void f3() { printf("f3 called\n"); }
void f4() { printf("f4 called\n"); }
void f5() { printf("f5 called\n"); }
void f6() { printf("f6 called\n"); }
void f7() { printf("f7 called\n"); }
void f8() { printf("f8 called\n"); }
int def_case() { return -1; }

void switchcase(int select) {
    switch (select) {
        case 0: f0(); break;
        case 1: f1(); break;
        case 2: f2(); break;
        case 3: f3(); break;
        case 4: f4(); break;
        case 5: f5(); break;
        case 6: f6(); break;
        case 7: f7(); break;
        case 8: f8(); break;
        default: def_case(); break;
    }
}

int main(int argc, char** argv) {
  int s = atoi(argv[1]);
  switchcase(s%9);
  return 0;
}
</code></pre></div></div> <p>The jump table (at 0x400938) in the .rodata section below has 9 elements. Similarly, the register rcx stores the de-referenced value depending on the local variable select from the table (before jmp rcx) where each table entry is the 8-byte value in size. Again, these values (fixups) should be updated for transformation.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ objdump -dj.text -M intel switchcase | grep -A20 "&lt;switchcase&gt;"
...(omitted)
  4007df:       0f 87 68 00 00 00       ja     40084d &lt;switchcase+0x8d&gt;
  4007e5:       48 8b 45 f0             mov    rax,QWORD PTR [rbp-0x10]
  4007e9:       48 8b 0c c5 38 09 40 00 mov    rcx,QWORD PTR [rax*8+0x400938]
  4007f1:       ff e1                   jmp    rcx
  4007f3:       e8 08 fe ff ff          call   400600 &lt;f0&gt;
  4007f8:       e9 58 00 00 00          jmp    400855 &lt;switchcase+0x95&gt;
...(omitted)

$ readelf -x .rodata switchcase
Hex dump of section '.rodata':
  0x00400930 01000200 00000000 f3074000 00000000 ..........@.....
  0x00400940 fd074000 00000000 07084000 00000000 ..@.......@.....
  0x00400950 11084000 00000000 1b084000 00000000 ..@.......@.....
  0x00400960 25084000 00000000 2f084000 00000000 %.@...../.@.....
  0x00400970 39084000 00000000 43084000 00000000 9.@.....C.@.....
  0x00400980 66302063 616c6c65 640a0066 31206361 f0 called..f1 ca
  0x00400990 6c6c6564 0a006632 2063616c 6c65640a lled..f2 called.
  0x004009a0 00663320 63616c6c 65640a00 66342063 .f3 called..f4 c
  0x004009b0 616c6c65 640a0066 35206361 6c6c6564 alled..f5 called
  0x004009c0 0a006636 2063616c 6c65640a 00663720 ..f6 called..f7
  0x004009d0 63616c6c 65640a00 66382063 616c6c65 called..f8 calle
  0x004009e0 640a00                              d..
</code></pre></div></div> <h4 id="iv-obtaining-metadata-from-the-llvm-backend"><strong>IV. Obtaining metadata from the LLVM Backend</strong></h4> <hr/> <p>Instead of restating how code randomization works in the paper, I’d like to mention some notable changes in the LLVM backend. But the best way to figure out the backend is to read the actual code with <a href="https://llvm.org/docs/CodeGenerator.html">the documentation from the official LLVM site</a>. Yongli has a long note on the LLVM target-independent code generator <a href="http://people.cs.pitt.edu/~yongli/notes/llvm3/LLVM3.html">here</a>.</p> <p>As shown in the previous examples, the layout information is essential to obtain function and basic block boundaries for fine-grained code randomization. The LLVM backend operates on internal hierarchical structures in a <strong><em>machine code (MC)  framework</em></strong>, consisting of <em>machine functions (MF), machine basic blocks (MBB), and machine instructions (MI)</em>. The framework then creates a new chunk of binary code, called a <strong><em>fragment,</em></strong> which is the building block of the section (MCSection). The assembler (MCAssembler) finally assembles various fragments (MCDataFragment,  MCRelaxableFragment and MCAlignmentFragment).</p> <p><a href="http://dandylife.net/blog/archives/743/fragments"><img src="http://dandylife.net/blog/wp-content/uploads/2018/05/fragments.png" alt=""/></a></p> <p>The figure above (Figure 3 in the paper) illustrates the relationship between the fragments and machine basic blocks in a single function as follows.</p> <ul> <li>Data fragments may span consecutive basic blocks. </li> <li>Relaxable fragments has a branch instruction, including a single fixup.</li> <li>Alignment fragments (padding) could be in between either basic blocks or functions.</li> </ul> <p>I have declared all variables with respect to the bookkeeping information for transformation in <a href="https://github.com/kevinkoo001/CCR/blob/master/llvm-3.9.0/include/llvm/MC/MCAsmInfo.h">include/llvm/MC/MCAsmInfo.h</a> as below because the class instance could be accessed easily in the LLVM backend. As the unit of the assembly process is the fragment to form a section - decoupled from any logical structure (i.e, MFs or MBBs) - there is no notion of functions and basic blocks under MC layer. Hence it is required to internally label MF and MBB per each instruction.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// class MCAsmInfo() in include/llvm/MC/MCAsmInfo.h
// (a) MachineBasicBlocks (map)
//    * MFID_MBBID: &lt;size, offset, # of fixups within MBB, alignments, type, sectionName&gt;
//    - The type field represents when the block is the end of MF or Object where MBB = 0, MF = 1, and Obj = 2
//    - The sectionOrdinal field is for C++ only; it tells current BBL belongs to which section!
mutable std::map&lt;std::string, std::tuple&lt;unsigned, unsigned, unsigned, unsigned, unsigned, std::string&gt;&gt; MachineBasicBlocks;
//    * MFID: fallThrough-ability
mutable std::map&lt;std::string, bool&gt; canMBBFallThrough;
//    * MachineFunctionID: size
mutable std::map&lt;unsigned, unsigned&gt; MachineFunctionSizes;
//    - The order of the ID in a binary should be maintained layout because it might be non-sequential.
mutable std::list&lt;std::string&gt; MBBLayoutOrder;

// (b) Fixups (list)
//    * &lt;offset, size, isRela, parentID, SymbolRefFixupName, isNewSection, secName, numJTEntries, JTEntrySz&gt;
//    - The last two elements are jump table information for FixupsText only,
//      which allows for updating the jump table entries (relative values) with pic/pie-enabled.
mutable std::list&lt;std::tuple&lt;unsigned, unsigned, bool, std::string, std::string, bool, std::string, unsigned, unsigned&gt;&gt; 
        FixupsText, FixupsRodata, FixupsData, FixupsDataRel, FixupsInitArray; 
//    - FixupsEhframe, FixupsExceptTable; (Not needed any more as a randomizer directly handles them later on)
//    - Keep track of the latest ID when parent ID is unavailable
mutable std::string latestParentID;

// (c) Others
//     The following method helps full-assembly file (*.s) identify functions and basic blocks
//     that inherently lacks their boundaries because neither MF nor MBB has been constructed.
mutable bool isAssemFile = false;
mutable std::string prevOpcode;
mutable unsigned assemFuncNo = 0xffffffff;
mutable unsigned assemBBLNo = 0;

  // Update emittedBytes from either DataFragment, RelaxableFragment or AlignFragment
void updateByteCounter(std::string id, unsigned emittedBytes, unsigned numFixups, \
                       bool isAlign, bool isInline) const {
  // std::string id = std::to_string(fnid) + "_" + std::to_string(bbid);
  // Create the tuple for the MBB
  if (MachineBasicBlocks.count(id) == 0) {
    MachineBasicBlocks[id] = std::make_tuple(0, 0, 0, 0, 0, "");
  }
  
  // Otherwise update MBB tuples
  std::get&lt;0&gt;(MachineBasicBlocks[id]) += emittedBytes; // Acutal size in MBB
  std::get&lt;2&gt;(MachineBasicBlocks[id]) += numFixups;    // Number of Fixups in MBB
  if (isAlign)
    std::get&lt;3&gt;(MachineBasicBlocks[id]) += emittedBytes;  // Count NOPs in MBB

  // If inlined, add the bytes in the next MBB instead of current one
  if (isInline)
    std::get&lt;0&gt;(MachineBasicBlocks[latestParentID]) -= emittedBytes;
}
</code></pre></div></div> <p>In order to gather the pre-defined set of metadata for randomization, it is needed to understand code generation in the LLVM backend. The following call stacks help how instructions are emitted. (*) sets up <em><strong>the parent of each instruction</strong></em> (MFID_MBBID) and <em><strong>fall-through-ability</strong></em>.  The property of fall-through is significant when performing randomization at a basic block level because relocating the fall-through BBL renders it unreachable (As we do not insert any trampoline (or instruction) by design, it forms a constraint during BBL-level transformation). (**)  collects the number of bytes of the instruction and the jump table corresponding to a certain fixup. Note that the size of the relaxable fragmentation is postponed until the MCAssember completes <a href="https://eli.thegreenplace.net/2013/01/03/assembler-relaxation">instruction relaxation</a> process. Check out the source files in my <a href="https://github.com/kevinkoo001/CCR">CCR repository</a>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--------------------------------------------------------------------------------------------
llvm::MCELFStreamer::EmitInstToData @lib/MC/MCELFStreamer.cpp (**)
llvm::MCObjectStreamer::EmitInstruction @lib/MC/MCObjectStreamer.cpp
--------------------------------------------------------------------------------------------
llvm::X86AsmPrinter::EmitAndCountInstruction@lib/Target/X86/X86MCInstLower.cpp(*)
llvm::X86AsmPrinter::EmitInstruction @lib/Target/X86/X86MCInstLower.cpp
--------------------------------------------------------------------------------------------
llvm::AsmPrinter::EmitFunctionBody @lib/CodeGen/AsmPrinter/AsmPrinter.cpp
llvm::X86AsmPrinter::runOnMachineFunction @lib/Target/X86/X86AsmPrinter.cpp
llvm::MachineFunctionPass::runOnFunction @lib/CodeGen/MachineFunctionPass.cpp
llvm::FPPassManager::runOnFunction @lib/IR/LegacyPassManager.cpp
llvm::FPPassManager::runOnModule @lib/IR/LegacyPassManager.cpp
    ::MPPassManager::runOnModule @lib/IR/LegacyPassManager.cpp
llvm::legacy::PassManagerImpl::run @lib/IR/LegacyPassManager.cpp
llvm::legacy::PassManager::run @lib/IR/LegacyPassManager.cpp
    ::EmitAssemblyHelper::EmitAssembly@tools/clang/lib/CodeGen/BackendUtil.cpp
clang::EmitBackendOutput @tools/clang/lib/CodeGen/BackendUtil.cpp              
clang::BackendConsumer::HandleTranslationUnit@tools/clang/lib/CodeGen/CodeGenAction.cpp    
clang::ParseAST@tools/clang/lib/Parse/ParseAST.cpp
clang::ASTFrontendAction::ExecuteAction@tools/clang/lib/Frontend/FrontendAction.cpp        
clang::CodeGenAction::ExecuteAction @tools/clang/lib/CodeGen/CodeGenAction.cpp
clang::FrontendAction::Execute @tools/clang/lib/Frontend/FrontendAction.cpp
clang::CompilerInstance::ExecuteAction@tools/clang/lib/Frontend/CompilerInstance.cpp
--------------------------------------------------------------------------------------------
clang::ExecuteCompilerInvocation@tools/clang/lib/FrontendTool/ExecuteCompilerInvocation.cpp
cc1_main @tools/clang/tools/driver/cc1_main.cpp
ExecuteCC1Tool @tools/clang/tools/driver/driver.cpp                                         
--------------------------------------------------------------------------------------------
main @tools/clang/tools/driver/driver.cpp
--------------------------------------------------------------------------------------------

// X86AsmPrinter::EmitInstruction() in lib/Target/X86/X86MCInstLower.cpp (*)
...(omitted)
MCInst TmpInst;
MCInstLowering.Lower(MI, TmpInst);

// Koo [Note] While converting MachineInstr into MCInst, it is essential to maintain
//            its parent MF and MBB because MCStreamer and MCAssembler do not care 
//            them any more semantically. After this phase, fragment and section govern.
const MachineBasicBlock *MBB = MI-&gt;getParent();
unsigned MBBID = MBB-&gt;getNumber();
unsigned MFID = MBB-&gt;getParent()-&gt;getFunctionNumber();
std::string ID = std::to_string(MFID) + "_" + std::to_string(MBBID);
TmpInst.setParent(ID);
  
// Koo [Note] Simple hack: both MF and MAI can be accessible, thus update fallThrough here.
const MCAsmInfo *MAI = getMCAsmInfo();
if (MAI-&gt;canMBBFallThrough.count(ID) == 0)
   MAI-&gt;canMBBFallThrough[ID] = MF-&gt;canMBBFallThrough[ID];
MAI-&gt;latestParentID = ID;

// MCELFStreamer::EmitInstToData() in lib/MC/MCELFStreamer.cpp (**)
// Add the fixups and data.
for (unsigned i = 0, e = Fixups.size(); i != e; ++i) {
  Fixups[i].setOffset(Fixups[i].getOffset() + DF-&gt;getContents().size());

  // Koo: Update a jump table corresponding to a fixup
  Fixups[i].setFixupParentID(ID);
  const MCExpr *FixupExpr = Fixups[i].getValue();
  std::string SymName;
  
  if (FixupExpr-&gt;getKind() == MCExpr::SymbolRef || FixupExpr-&gt;getKind() == MCExpr::Binary) {
    std::string JTPrefix = ".LJTI";
    if (FixupExpr-&gt;getKind() == MCExpr::SymbolRef) {
      const MCSymbolRefExpr &amp;SRE1 = cast&lt;MCSymbolRefExpr&gt;(*FixupExpr);
      const MCSymbol &amp;Sym1 = SRE1.getSymbol();
      SymName = Sym1.getName().str();
    }
    
    // This code is added because of pic/pie option
    //    Fixup kind is "MCExpr::Binary" rather than "MCExpr::SymbolRef"
    //    So here we evaluate BE.getLHS() instead
    if (FixupExpr-&gt;getKind() == MCExpr::Binary) {
      const MCBinaryExpr &amp;BE = cast&lt;MCBinaryExpr&gt;(*FixupExpr);
      if (isa&lt;MCSymbolRefExpr&gt;(BE.getLHS())) {
        const MCSymbolRefExpr &amp;SRE2 = cast&lt;MCSymbolRefExpr&gt;(*BE.getLHS());
        const MCSymbol &amp;Sym2 = SRE2.getSymbol();
        SymName = Sym2.getName().str();
      }
    }
    
    // Update the symbol reference for JT only for now.
    if (SymName.find(JTPrefix) != std::string::npos) {
      Fixups[i].setIsJumpTableRef(true);
      Fixups[i].setSymbolRefFixupName(SymName.substr(JTPrefix.length(), SymName.length()));
    }
  }
  DF-&gt;getFixups().push_back(Fixups[i]);
}

DF-&gt;setHasInstructions(true);
DF-&gt;getContents().append(Code.begin(), Code.end());

// Koo: Here combines the emitted data as MCDataFragment
//      addMachineBasicBlockTag() keeps track of the IDs that identifies (MFID_MBBID) pair
//      MCRelaxableFragment will be generating in MCObjectStreamer::EmitInstToFragment()
unsigned EmittedBytes = Code.size();
const MCAsmInfo *MAI = Assembler.getContext().getAsmInfo();
unsigned numFixups = Fixups.size();

// Sometimes there exists the instruction with missing parentID (!!!!)
// Another corner case: However, we need to update the emitted bytes anyways
// For example, "cld; rep; stosq\n" emits 0xFC, (0xF3, 0x48), and 0xAB respectively with no parentID
if (ID.length() == 0)
  ID = MAI-&gt;latestParentID;

DF-&gt;setLastParentTag(ID);
DF-&gt;addMachineBasicBlockTag(ID);
MAI-&gt;updateByteCounter(ID, EmittedBytes, numFixups, /*isAlign=*/ false, /*isInline=*/ false);

unsigned size, offset, fixups, alignments, type;
std::string sectionName;
std::tie(size, offset, fixups, alignments, type, sectionName) = MAI-&gt;MachineBasicBlocks[ID];

MAI-&gt;latestParentID = ID;
...(omitted)
</code></pre></div></div> <p>Next, the jump table information could be collected in <a href="https://github.com/kevinkoo001/CCR/blob/master/llvm-3.9.0/lib/CodeGen/BranchFolding.cpp">lib/CodeGen/BranchFolding.cpp</a>. The tricky part was to spot the final jump table because it keeps updated as optimization goes. In the MF, we walk through all jump table entries, thereby obtain the target MBBs.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// RecordMachineJumpTableInfo() in /lib/CodeGen/MachineFunction.cpp

// Koo - As optimization goes, MJTI might keep being updated from the followings
//        a) MachineFunctionPass::SelectionDAGISel::X86DAGToDAGISel::runOnMachineFunction() 
//        b) MachineFunctionPass::BranchFolderPass::runOnMachineFunction() 
void MachineFunction::RecordMachineJumpTableInfo(MachineJumpTableInfo *MJTI) {
  const std::vector&lt;MachineJumpTableEntry&gt; &amp;JT = MJTI-&gt;getJumpTables();
  
  if (!JT.empty()) {
    const MachineModuleInfo &amp;MMI = this-&gt;getMMI();
    const MCObjectFileInfo* MOFI = MMI.getMCObjectFileInfo();
    
    if (!MOFI) return;
        
    // Walk through all Jump Tables in this Machine Function
    for (unsigned JTI = 0, e = JT.size(); JTI != e; ++JTI) {
      const std::vector&lt;MachineBasicBlock*&gt; &amp;JTBBs = JT[JTI].MBBs;
      unsigned MFID = this-&gt;getFunctionNumber();
      
      // Key: &lt;MachineFunctionIdx_JumpTableIdx&gt;
      std::string MJTKey = std::to_string(MFID) + "_" + std::to_string(JTI); 
      std::list&lt;std::string&gt; JTEntries;
      // Walk through all Jump Table Entries (MBBs) to get targets
      for (unsigned ii = 0, ee = JTBBs.size(); ii != ee; ++ii) {
        unsigned MBBID = JTBBs[ii]-&gt;getNumber();
        JTEntries.push_back(std::to_string(MFID) + "_" + std::to_string(MBBID));
      }
    
      // Value: &lt;(EntryKind, EntrySize, Entries[MFID_MBBID])&gt;
      unsigned EntryKind = MJTI-&gt;getEntryKind();
      unsigned EntrySize = MJTI-&gt;getEntrySize(this-&gt;getDataLayout());
      MOFI-&gt;updateJumpTableTargets(MJTKey, EntryKind, EntrySize, JTEntries);
    }
  }
}

// BranchFolderPass::runOnMachineFunction() in lib/CodeGen/BranchFolding.cpp
...(omitted)
// Koo - The final JTInfo, which could be overriden
//       For example lib/Target/X86/X86ISelDAGToDAG.cpp for x86
MachineJumpTableInfo *MJTI = MF.getJumpTableInfo();
if (MJTI)
  MF.RecordMachineJumpTableInfo(MJTI);
</code></pre></div></div> <p>MCAssembler performs several important tasks prior to emitting the final binary as follows. It allows for ultimate metadata collection, followed by serializing it to our own section (called .rand). The code snippets below show part of these jobs.</p> <ul> <li>Finalize the layout of fragments and sections</li> <li>Attempt to resolve fixups, and records a relocation if unresolved</li> <li> <p>Check if a relaxable fragment needs relaxation</p> <p>// MCAssembler::layout() in lib/MC/MCAssembler.cpp …(omitted) // Koo: Collect what we need once layout has been finalized const MCAsmInfo *MAI = Layout.getAssembler().getContext().getAsmInfo(); const MCObjectFileInfo *MOFI = Layout.getAssembler().getContext().getObjectFileInfo(); bool isNewTextSection = false, isNewRodataSection = false; bool isNewDataSection = false, isNewDataRelSection = false, isNewInitSection = false; unsigned textSecCtr = 0, rodataSecCtr = 0, dataSecCtr = 0, dataRelSecCtr = 0, initSecCtr = 0; unsigned prevLayoutOrder;</p> <p>// Evaluate and apply the fixups, generating relocation entries as necessary. for (MCSection &amp;Sec : *this) { // Koo MCSectionELF &amp;ELFSec = static_cast&lt;MCSectionELF &amp;&gt;(Sec); std::string secName = ELFSec.getSectionName(); unsigned layoutOrder = ELFSec.getLayoutOrder();</p> <p>for (MCFragment &amp;Frag : Sec) { // Data and relaxable fragments both have fixups. So only process // those here. // FIXME: Is there a better way to do this? MCEncodedFragmentWithFixups // being templated makes this tricky.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Koo - Attach the size of the alignment to the previous fragment.
//       Here assumes a) no two alignments are consecutive.
//                    b) data fragment (DF or RF) exists prior to AF. (may be broken in assembly)
uint64_t fragOffset = Frag.getOffset();
MCFragment *prevFrag;
    
if (isa&lt;MCDataFragment&gt;(&amp;Frag) &amp;&amp; Frag.hasInstructions())
  prevFrag = static_cast&lt;MCDataFragment*&gt;(&amp;Frag);
  
if (isa&lt;MCRelaxableFragment&gt;(&amp;Frag) &amp;&amp; Frag.hasInstructions())
  prevFrag = static_cast&lt;MCRelaxableFragment*&gt;(&amp;Frag);
  
// Update alignment size to reflect to the size of MF and MBB
if (MOFI-&gt;getObjectFileType() == llvm::MCObjectFileInfo::IsELF &amp;&amp; \
   secName.find(".text") == 0 &amp;&amp; (isa&lt;MCAlignFragment&gt;(&amp;Frag)) &amp;&amp; fragOffset &gt; 0) {
   // Push this alignment to the previous MBB and the MF that the MBB belongs to
   unsigned alignSize;
   std::string ID;
   if (isa&lt;MCDataFragment&gt;(*prevFrag))
     ID = static_cast&lt;MCDataFragment*&gt;(prevFrag)-&gt;getLastParentTag();
   if (isa&lt;MCRelaxableFragment&gt;(*prevFrag))
     ID = static_cast&lt;MCRelaxableFragment*&gt;(prevFrag)-&gt;getInst().getParent();
       
   alignSize = computeFragmentSize(Layout, Frag);
   MAI-&gt;updateByteCounter(ID, alignSize, 0, /*isAlign=*/ true, /*isInline=*/ false);
} ...(omitted) for (const MCFixup &amp;Fixup : Fixups) {
  uint64_t FixedValue;
  bool IsResolved;
  bool IsPCRel; // Koo
  MCValue Target;
  std::tie(Target, FixedValue, IsResolved) =
  std::tie(Target, FixedValue, IsResolved, IsPCRel) = // Koo
      handleFixup(Layout, Frag, Fixup);
  getBackend().applyFixup(*this, Fixup, Target, Contents, FixedValue,
                          IsResolved);
                              
  // Koo: Collect fixups here (ELF format only)
  if (MOFI-&gt;getObjectFileType() == llvm::MCObjectFileInfo::IsELF) {
      unsigned offset = fragOffset + Fixup.getOffset();
      unsigned derefSize = 1 &lt;&lt; getBackend().getFixupKindLog2Size(Fixup.getKind());
      unsigned jtEntryKind = 0, jtEntrySize = 0, numJTEntries = 0;
      std::map&lt;std::string, std::tuple&lt;unsigned, unsigned, std::list&lt;std::string&gt;&gt;&gt; JTs = MOFI-&gt;getJumpTableTargets();
      std::string fixupParentID = Fixup.getFixupParentID();
      std::string SymbolRefFixupName = Fixup.getSymbolRefFixupName();
      std::list&lt;std::string&gt; JTEs; // contains all target(MFID_MBBID) in the JT
          
      // The following handles multiple sections in C++
      if (secName.find(".text") == 0) {
        if (textSecCtr == 0) {
          prevLayoutOrder = layoutOrder;
          textSecCtr++;
        }
        else {
          isNewTextSection = (layoutOrder == prevLayoutOrder) ? false:true;
          if (isNewTextSection) textSecCtr++;
          prevLayoutOrder = layoutOrder;
        }
        if (Fixup.getIsJumpTableRef()) {
          std::tie(jtEntryKind, jtEntrySize, JTEs) = JTs[Fixup.getSymbolRefFixupName()];
          numJTEntries = JTEs.size();
        }
        MAI-&gt;FixupsText.push_back(std::make_tuple(offset, derefSize, IsPCRel, \
             fixupParentID, SymbolRefFixupName, isNewTextSection, secName, numJTEntries, jtEntrySize));
      } ...(omitted)
</code></pre></div> </div> <p>// MCAssembler::relaxInstruction() in lib/MC/MCAssembler.cpp // This method plays a role to determine if relaxation is needed</p> <p>if (!fragmentNeedsRelaxation(&amp;F, Layout)) // Koo // Whether or not the instruction has been relaxed // The RelaxableFragment must be counted as the emitted bytes const MCAsmInfo *MAI = Layout.getAssembler().getContext().getAsmInfo(); std::string ID = F.getInst().getParent(); unsigned relaxedBytes = F.getRelaxedBytes(); unsigned fixupCtr = F.getFixup();</p> <p>if (!fragmentNeedsRelaxation(&amp;F, Layout)) { // [Case 1] Unrelaxed instruction if (ID.length() &gt; 0) { unsigned curBytes = F.getInst().getByteCtr(); if (relaxedBytes &lt; curBytes) { // RelaxableFragment always contains relaxedBytes and fixupCtr variable // for the adjustment in case of re-evaluation (simple hack but tricky) MAI-&gt;updateByteCounter(ID, curBytes - relaxedBytes, 1 - fixupCtr, /<em>isAlign=</em>/ false, /<em>isInline=</em>/ false); F.setRelaxedBytes(curBytes); F.setFixup(1);</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // If this fixup points to Jump Table Symbol, update it.
    F.getFixups()[0].setFixupParentID(ID);
  }
}
return false;
</code></pre></div> </div> <p>} …(omitted) F.getContents() = Code; F.getFixups() = Fixups;</p> <p>// Koo [Case 2] Relaxed instruction: // The only relaxations X86 does is from a 1byte pcrel to a 4byte pcrel // Note: The relaxable fragment could be re-evaluated multiple times for relaxation // Thus update it only if the relaxable fragment has not been relaxed previously if (relaxedBytes &lt; Code.size() &amp;&amp; ID.length() &gt; 0) { MAI-&gt;updateByteCounter(ID, Code.size() - relaxedBytes, 1 - fixupCtr, <br/> /<em>isAlign=</em>/ false, /<em>isInline=</em>/ false); F.setRelaxedBytes(Code.size()); F.setFixup(1); F.getFixups()[0].setFixupParentID(ID); }</p> <p>return true;</p> </li> </ul> <p>Lastly, the following code is purely for metadata serialization according to protobuf definition (See the section V) in <a href="https://github.com/kevinkoo001/CCR/blob/master/llvm-3.9.0/lib/MC/MCAssembler.cpp">lib/MC/MCAssembler.cpp</a>. </p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Koo: Serialize the metadata with Google's protocol buffer format, calling from
//      ELFObjectWriter::writeSectionData() in writeObject()@ELFObjectWriter.cpp

void MCAssembler::WriteRandInfo(const MCAsmLayout &amp;Layout) const {
  ShuffleInfo::ReorderInfo reorder_info;
  serializeReorderInfo(&amp;reorder_info, Layout);
  std::string randContents;
  
  if (!reorder_info.SerializeToString(&amp;randContents)) {
    errs() &lt;&lt; "[CCR-Error] MCAssembler::WriteRandInfo - Failed to serialize the shuffling information to .rand section! \n";
  }
  
  MCObjectWriter&amp; OW = (*this).getWriter();
  OW.writeBytes(randContents);
  std::string objFileName(Layout.getAssembler().getContext().getMainFileName());
  
  if (objFileName.length() == 0)
    objFileName = getObjTmpName();

  DEBUG_WITH_TYPE("ccr-metadata", dbgs() &lt;&lt; "Successfully wrote the metadata in a .rand section for " &lt;&lt; objFileName &lt;&lt; "\n");
  google::protobuf::ShutdownProtobufLibrary();
}

// Koo: Serialize all information for future reordering, which has been stored in MCAsmInfo
void serializeReorderInfo(ShuffleInfo::ReorderInfo* ri, const MCAsmLayout &amp;Layout) {
  // Set the binary information for reordering
  ShuffleInfo::ReorderInfo_BinaryInfo* binaryInfo = ri-&gt;mutable_bin();
  binaryInfo-&gt;set_rand_obj_offset(0x0); // Should be updated at linking time
  binaryInfo-&gt;set_main_addr_offset(0x0);    // Should be updated at linking time 
  
  const MCAsmInfo *MAI = Layout.getAssembler().getContext().getAsmInfo();
  updateReorderInfoValues(Layout);
  
  // Set the layout of both Machine Functions and Machine Basic Blocks with protobuf definition
  std::string sectionName;
  unsigned MBBSize, MBBoffset, numFixups, alignSize, MBBtype;
  unsigned objSz = 0, numFuncs = 0, numBBs = 0;
  int MFID, MBBID, prevMFID = 0;

  for (auto MBBI = MAI-&gt;MBBLayoutOrder.begin(); MBBI != MAI-&gt;MBBLayoutOrder.end(); ++MBBI) {
    ShuffleInfo::ReorderInfo_LayoutInfo* layoutInfo = ri-&gt;add_layout();
    std::string ID = *MBBI;
    std::tie(MFID, MBBID) = separateID(ID);
    std::tie(MBBSize, MBBoffset, numFixups, alignSize, MBBtype, sectionName) = MAI-&gt;MachineBasicBlocks[ID];
    bool MBBFallThrough = MAI-&gt;canMBBFallThrough[ID];
 
    layoutInfo-&gt;set_bb_size(MBBSize);
    layoutInfo-&gt;set_type(MBBtype);
    layoutInfo-&gt;set_num_fixups(numFixups);
    layoutInfo-&gt;set_bb_fallthrough(MBBFallThrough);
    layoutInfo-&gt;set_section_name(sectionName);
    
    if (MFID &gt; prevMFID) {
      numFuncs++;
      numBBs = 0;
    }
    
    objSz += MBBSize;
    numBBs++;
    prevMFID = MFID;
  }

  binaryInfo-&gt;set_obj_sz(objSz);
  
  // Set the fixup information (.text, .rodata, .data, .data.rel.ro and .init_array)
  ShuffleInfo::ReorderInfo_FixupInfo* fixupInfo = ri-&gt;add_fixup();
  setFixups(MAI-&gt;FixupsText, fixupInfo, ".text");
  setFixups(MAI-&gt;FixupsRodata, fixupInfo, ".rodata");
  setFixups(MAI-&gt;FixupsData, fixupInfo, ".data");
  setFixups(MAI-&gt;FixupsDataRel, fixupInfo, ".data.rel.ro");
  setFixups(MAI-&gt;FixupsInitArray, fixupInfo, ".init_array");
  
  // Show the fixup information for each section
  DEBUG_WITH_TYPE("ccr-metadata", dbgs() &lt;&lt; "\n&lt;Fixups Summary&gt;\n");
  dumpFixups(MAI-&gt;FixupsText, "text", /*isDebug*/ false);
  dumpFixups(MAI-&gt;FixupsRodata, "rodata", false);
  dumpFixups(MAI-&gt;FixupsData, "data", false);
  dumpFixups(MAI-&gt;FixupsDataRel, "data.rel.ro", false);
  dumpFixups(MAI-&gt;FixupsInitArray, "init_array", false);
}
</code></pre></div></div> <h4 id="v-metadata-definition-with-googles-protocol-buffers"><strong>V. Metadata Definition with Google’s Protocol Buffers</strong></h4> <hr/> <p>We employee <a href="https://developers.google.com/protocol-buffers/"><em>Google’s Protocol Buffers (protobuf)</em></a> to serialize the collected metadata systematically because it provide a clean, efficient and portable interface for structured data streams. As our randomizer has been written in Python, the unified data serialization and de-serialization greatly reduces the complexity to transfer metadata from C++.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// This file defines the buffer protocol of the shuffleInfo for reordering.
// The following command automatically generates both the declaration 
// and the implementation of shuffleInfo class.
//    $ protoc --cpp_out=$DST_DIR shuffleInfo.proto       # C++
//    $ protoc --python_out=$DST_DIR shuffleInfo.proto    # Python
// The following command generates the shared object.
//    $ c++ -fPIC -shared shuffleInfo.pb.cc -o shuffleInfo.so `pkg-config --cflags --libs protobuf`

syntax = "proto2";
package ShuffleInfo;

message ReorderInfo {

  // Binary info from ld or ld.gold; reordering range and main offset
  message BinaryInfo {
    optional uint32 rand_obj_offset = 1;  // PLACEHOLDER FOR LINKER
    optional uint32 main_addr_offset = 2; // PLACEHOLDER FOR LINKER
    optional uint32 obj_sz = 3;           // Verification purpose
  }

  // Code Layout Info (.text) from LLVM
  // Embeded info ([#func|#fixup]/obj, [#bbk|#fixup]/func, objSz/ea, funcSz/ea)
  message LayoutInfo {
    optional uint32 bb_size = 1;          // UPDATE AT LINKTIME WITH OBJ ALIGNMENTs
                                          // All alignments between fn/bbl are included here
    optional uint32 type = 2;             // Represents the end of [OBJ|FUN|BBL]
    optional uint32 num_fixups = 3;
    optional bool bb_fallthrough = 4;
    optional string section_name = 5;     // section identifier in c++ mutiple sections
  }

  // Fixup info in ELF from LLVM
  message FixupInfo {
    message FixupTuple {
      required uint32 offset = 1;         // UPDATE AT LINKTIME WHEN COMBINING SECTIONS
      required uint32 deref_sz = 2;
      required bool   is_rela = 3;
      optional uint32 type = 4;           // c2c, c2d, d2c, d2d = (0-3)
      optional string section_name = 5;   // section identifier in c++ mutiple sections
                                          // fixup has a jump table (.rodata) for pic/pie use
      optional uint32 num_jt_entries = 6; // number of the jump table entries
      optional uint32 jt_entry_sz = 7;    // size of each jump table entry in byte
    }
    repeated FixupTuple text = 1;
    repeated FixupTuple rodata = 2;
    repeated FixupTuple data = 3;
    repeated FixupTuple datarel = 4;
    repeated FixupTuple initarray = 5;
  }

  optional BinaryInfo bin = 1;
  repeated LayoutInfo layout = 2;
  repeated FixupInfo fixup = 3;
}
</code></pre></div></div> <p>The protobuf definition of the metadata uses a compact representation by having the minimum amount of information in need. For instance, the LayoutInfo message only keeps the size of basic block layout with the type of the basic block (The BBL type record denotes whether BBL belongs to the end of a function, the end of an object or both), which will later be reconstructed by the randomizer based on it. Note that section names in LayoutInfo and FixupInfo messages won’t be remained in the metadata (.rand section) of the final executable. They are only useful to identify multiple sections for C++ applications at link time. </p> <h4 id="vi-consolidating-metadata-in-the-gold-linker"><strong>VI. Consolidating Metadata in the gold Linker</strong></h4> <hr/> <p>In a nutshell, the main task of the linker is to combine multiple object files generated by compiler into a single executable. It could be broken into three parts: a) constructing final layout, b) resolving symbols, and c) updating relocations. The following figure well illustrates how every metadata per each object file could be merged with appropriate updates (adjustment will be made for BBL sizes, fixup offsets and so forth) as the layout is finalized at link time. <a href="http://dandylife.net/blog/?attachment_id=824"><img src="http://dandylife.net/blog/wp-content/uploads/2018/05/linking.png" alt=""/></a></p> <h4 id="vii-randomizer-dubbed-prander"><strong>VII. Randomizer (dubbed prander)</strong></h4> <hr/> <p>CCR supports fine-grained transformation at a both function and basic block level. But we have opted to maintain some constraints imposed by the code layout in order to strike a balance between efficiency (performance) and effectiveness (randomization entropy). The current choice simplifies reordering process and helps in maintaining spatial locality in caching strategy. To this end, we prioritize basic block reordering at intra-function level, and then proceed with function-level reordering.</p> <p><a href="http://dandylife.net/blog/?attachment_id=825"><img src="http://dandylife.net/blog/wp-content/uploads/2018/05/constraint.png" alt=""/></a></p> <p>The figure above explains the two constraints mainly due to fixup size: a function that contains a short fixup (i.e,. 1-byte) as part of jump instruction used for tail-call optimization and a basic block that contains any distance-limiting fixup. Let’s say the left part represents the original layout, whereas the middle and the right ones correspond to function and basic block reordering, respectively. In this example, suppose that: i) control can fall through from BBL #0 to BBL #1; ii) fixup (a) in FUN #1 refers to a location in a different function (FUN #2.); and iii) fixup (b) corresponds to a single-byte reference from BBL #4 to BBL #3. Basic blocks #0 and #1 are always displaced together due to the first constraint, as also is the case for #3 and #4 due to the third constraint.</p> <p>The following shows main components of the randomizer (referred to as prander) at a glance. The prander parses the augmented ELF binary, reading metadata (a). It constructs an internal tree data structure (binary - object(s)- function(s) - basic block(s); note that fixup may or may not appear) (b), followed by performing transformation considering constraints based on the structure (c). Finally, it then builds an instrumented (sane) binary after patching all required ELF sections (d).</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(a) ElfParser               (b) ReorderInfo        
+----------------------+    +------------------+   ELF Sections to be patched
| readElfHeader()      |    | BinaryInfo()     |   +---------------+
| readMetadata()       |    | ObjectInfo()     |   | .text         |
| metadataSanityCheck()|    | FunctionInfo()   |   | .data         |
+----------------------+    | BasicBlockInfo() |   | .rodata       |
                            | FixupInfo()      |   | .data.rel.ro  |
                            +------------------+   | .init_array   |
(c) ReorderEngine           (d) BinaryBuilder      | .rela.dyn     |
+----------------------+    +------------------+   | .dynsym       |
| resolveConstraints() |    | checkOrigBin()   |   | .symtab       |
| updateFixups()       |    | patchSections()  |--&gt;| .eh_frame     |
| performTransform()   |    | emitInstBinary() |   | .eh_frame_hdr |
+----------------------+    +------------------+   +---------------+
</code></pre></div></div> <p><a href="http://dandylife.net/blog/archives/743/tree_structure"><img src="http://dandylife.net/blog/wp-content/uploads/2018/05/tree_structure.png" alt=""/></a><br/> Putting all together, the next is a sample output of a program compiled with CCR, <a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">putty</a>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python ./CCR/randomizer/prander.py -s -b ./putty
    ___   ___   __         ___                     _
   / __\ / __\ /__\       / _ \_ __ __ _ _ __   __| | ___ _ __
  / /   / /   / \//_____ / /_)/ '__/ _` | '_ \ / _` |/ _ \ '__|
 / /___/ /___/ _  \_____/ ___/| | | (_| | | | | (_| |  __/ |
 \____/\____/\/ \_/     \/    |_|  \__,_|_| |_|\__,_|\___|_/

 Compiler-assisted Code Randomization: Practical Randomizer
 (In the 39th IEEE Symposium on Security &amp; Privacy 2018)

 [INFO   ] Reading the metadata from the .rand section... (shuffleInfoReader.py:139)
 [INFO   ]       Offset to the object  : 0x100 (shuffleInfoReader.py:140)
 [INFO   ]       Offset to the main()  : 0x20 (shuffleInfoReader.py:141)
 [INFO   ]       Total Emitted Bytes   : 0x863f0 (shuffleInfoReader.py:142)
 [INFO   ]       Number of Objects     : 79 (shuffleInfoReader.py:143)
 [INFO   ]       Number of Functions   : 1288 (shuffleInfoReader.py:144)
 [INFO   ]       Number of Basic Blocks: 20712 (shuffleInfoReader.py:145)
 [INFO   ]       Fixups in .text : 32467  (shuffleInfoReader.py:56)
 [INFO   ]       Fixups in .rodata       : 4583  (shuffleInfoReader.py:56)
 [INFO   ]       Fixups in .data : 118  (shuffleInfoReader.py:56)
 [INFO   ]       Number of Jump Tables : 85 (shuffleInfoReader.py:173)
 [INFO   ] Building up the layout... (prander.py:43)
                 100% [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
 [INFO   ] Sanity check for ./putty...  (reorderInfo.py:580)
 [WARNING]       [.text] Fails to discover the reference BBL (Fixup#16116) (reorderInfo.py:470)
 [WARNING]       [.text] Fails to discover the reference BBL (Fixup#16117) (reorderInfo.py:470)
 [WARNING]       [.text] Fails to discover the reference BBL (Fixup#16637) (reorderInfo.py:470)
 [WARNING]       [.text] Fails to discover the reference BBL (Fixup#16638) (reorderInfo.py:470)
 [WARNING]       [.text] Fails to discover the reference BBL (Fixup#16639) (reorderInfo.py:470)
 [WARNING]       [.text] Fails to discover the reference BBL (Fixup#16744) (reorderInfo.py:470)
 [WARNING]       [.text] Fails to discover the reference BBL (Fixup#16745) (reorderInfo.py:470)
 [CRITICAL]      Verification for Fixups in .text section has been failed! (reorderInfo.py:594)
 [INFO   ]       All sanity checks have been PASSED!! (reorderInfo.py:605)
 [INFO   ] Performing reordering (@BBL)... (prander.py:48)
 [INFO   ]       # of Function Constraints: 17 (reorderEngine.py:216)
 [INFO   ] Instrumenting the binary... (prander.py:66)
 [INFO   ]       Processing section [.dynsym] (binaryBuilder.py:694)
                 100% [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
 [INFO   ]       Processing section [.rela.dyn] (binaryBuilder.py:694)
 [INFO   ]       Processing section [.text] (binaryBuilder.py:694)
                 100% [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
 [INFO   ]       Processing section [.rodata] (binaryBuilder.py:694)
                 100% [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
 [INFO   ]       Processing section [.eh_frame] (binaryBuilder.py:694)
 [INFO   ]       Processing section [.eh_frame_hdr] (binaryBuilder.py:694)
 [INFO   ]       Processing section [.init_array] (binaryBuilder.py:694)
 [INFO   ]       Processing section [.data] (binaryBuilder.py:694)
                 100% [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
 [INFO   ]       Processing section [.symtab] (binaryBuilder.py:694)
                 100% [&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;]
 [INFO   ] Summary of Binary Instrumentation (report.py:81)
 [INFO   ]       Binary Name       : ./putty_shuffled (report.py:82)
 [INFO   ]       Main() Addr       : 0x48b520 -&gt; 0x48edb0 (report.py:85)
 [INFO   ]       Symbol Patches    : 1288 (.dynsym|.symtab) (report.py:92)
 [INFO   ]       InitArray Patches : 0 (.init_array) (report.py:93)
 [INFO   ]       CIE / FDE         : 2 / 1294 (.eh_frame) (report.py:94)
 [INFO   ]       FDE Patches       : 1288 (.eh_frame) (report.py:95)
 [INFO   ]       Pair Patches      : 1288 (.eh_frame_hdr) (report.py:96)
 [INFO   ]       Original MD5      : 105bc873fab73a4cb6bca9e1746188d3 (report.py:98)
 [INFO   ]       Shuffled MD5      : c795effe6de63f3f96e3f1cd2e4b5fbc (report.py:99)
 [INFO   ]       Shuffled Size     : 0x0863f0 (report.py:100)
 [INFO   ]       Metadata size     : 0x01e766 (report.py:101)
 [INFO   ]       Total Size        : 0x27cbe8 (report.py:102)
 [INFO   ]       File Inc Rate     : 4.784% (report.py:103)
 [INFO   ]       Entropy [LB, UB]  : [10^3392.23, 10^3866.66] possible versions (report.py:77)
 [INFO   ] Total elapsed time: 18.154 sec(s) (prander.py:77)
 [INFO   ] Success!! The log has been saved to ./putty.log (prander.py:162)
</code></pre></div></div> <h4 id="viii-evaluation-see-the-paper-for-more-detail"><strong>VIII. Evaluation (see the paper for more detail)</strong></h4> <hr/> <p>**A. Randomization Overhead<br/> **</p> <p>With SPEC CPU2006 benchmark suite (20 C/C++ programs), we generated 20 different variants (with -O2 optimization and no PIC option) including 10 function reordering and 10 basic block reordering. The average overhead was <strong>0.28%</strong> with a 1.37 standard deviation.</p> <p><strong>B. Size increase</strong></p> <p>Based on the benchmark suite, it was a modest increase of <strong>13.3%</strong> on average to store metadata. Note that the final executable for distribution embeds the compressed metadata with gzip, whereas a variant does not.</p> <p><a href="http://dandylife.net/blog/?attachment_id=829"><img src="http://dandylife.net/blog/wp-content/uploads/2018/05/overhead.png" alt=""/></a></p> <p><strong>C. Entropy</strong><br/> <a href="http://dandylife.net/blog/archives/743/entropy"><img src="http://dandylife.net/blog/wp-content/uploads/2018/05/entropy.png" alt=""/></a><br/> where<br/> <strong>p</strong>: the number of object files in a binary<br/> <strong>Fij</strong>: the _j_th function in the _i_th object<br/> <strong>fi</strong>: the number of functions in the object<br/> <strong>bij</strong>: the number of basic blocks in the function Fij<br/> <strong>xij</strong>: the number of basic blocks that has a constraint<br/> <strong>yj</strong>: the number of functions that has a constraint<br/> <strong>E</strong>: Entropy with the base 10 logarithm</p> <p>Finally, my presentation in <em>Security and Privacy 2018</em> is also available. <br/> [youtube https://www.youtube.com/watch?v=xIAeyLJ0hKw]</p>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Attack &amp;amp; Defense, Cyber Warfare"/><category term="return oriented programming"/><category term="rop"/><category term="software diversity"/><summary type="html"><![CDATA[I. Motivation II. Compiler-assisted Code Randomization (CCR) Overview III. Identifying Essential Information for Randomization IV. Obtaining Metadata from the LLVM Backend V. Metadata Definition with Google’s Protocol Buffers VI. Consolidating Metadata in the gold Linker VII. Randomizer  VIII. Evaluation]]></summary></entry><entry><title type="html">ELF Sections for Exception Handling</title><link href="https://kevinkoo001.github.io/blog/2017/elf-sections-for-exception-handling/" rel="alternate" type="text/html" title="ELF Sections for Exception Handling"/><published>2017-09-05T04:57:10+00:00</published><updated>2017-09-05T04:57:10+00:00</updated><id>https://kevinkoo001.github.io/blog/2017/elf-sections-for-exception-handling</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2017/elf-sections-for-exception-handling/"><![CDATA[<p>In ELF binary, there are two sections to support exception handling routines that are predominately used by C++ applications: <em>.eh_frame</em> and <em> .eh_frame_hdr</em>. However, <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">System V Application Binary Interface (ABI) for AMD64</a> mandates to have those sections even they are written in C.</p> <p><strong>a) .<em>eh_frame</em> section</strong></p> <p>The .<em>eh_frame</em> section has the same structure with <em>.debug_frame</em>, which follows <a href="http://www.dwarfstd.org/doc/DWARF4.pdf">DWARF</a> format. It represents the table that describes how to set registers to restore the previous call frame at runtime. DWARF designers allow for having flexible mechanism to be able to unwind the stack with various expressions including constant values, arithmetic, memory dereference, register contents, and control flow.</p> <p>The <em>.eh_frame</em> section contains at least one or more Call Frame Information (CFI) records. Each CFI consists of two entry forms: Common Information Entry (CIE) and Frame Description Entry (FDE). Every CFI has a single CIE and one or more FDEs. CFI usually corresponds to a single object file. Likewise, so does FDE to a single function. However, there might be multiple CIEs and FDEs corresponding to the parts of a function when the function has a non-contiguous range in a virtual memory space. The following shows the fields of each entry in detail.</p> <table width="553"><tbody><tr> <td width="183">**CIE Fields** </td> <td width="157">**Data Format** </td> <td width="213">**Description** </td></tr><tr> <td>length  </td> <td>4 bytes </td> <td>Total length of the CIE except this field </td></tr><tr> <td>CIE_id  </td> <td>4 or 8 bytes </td> <td>0 for .eh_frame </td></tr><tr> <td>Version  </td> <td>1 byte </td> <td>Value 1 </td></tr><tr> <td>Augmentation  </td> <td>A null-terminated UTF-8 string </td> <td>0 if no augmetation </td></tr><tr> <td>Code alignment factor  </td> <td>unsigned LEB128 </td> <td>Usually 1 </td></tr><tr> <td>Data alignment factor  </td> <td>signed LEB128 </td> <td>Usually -4 (encoded as 0x7C) </td></tr><tr> <td>return_address_register  </td> <td>unsigned LEB128 </td> <td>Dwarf number of the return register </td></tr><tr> <td>Augmentation data length  </td> <td>unsigned LEB128 </td> <td>Present if Augmentation has 'z' </td></tr><tr> <td>Initial instructions </td> <td>array of bytes </td> <td>Dwarf Call Frame Instructions </td></tr><tr> <td>padding </td> <td>array of bytes </td> <td>DW_CFA_nop instructions to match the length </td></tr></tbody></table> <table width="553"><tbody><tr> <td width="183">**FDE Fields** </td> <td width="157">**Data Format** </td> <td width="213">**Description** </td></tr><tr> <td>Length  </td> <td>4 bytes </td> <td>Total length of the FDE except this field; 0 means end of all records </td></tr><tr> <td>CIE pointer  </td> <td>4 or 8 bytes </td> <td>Distance to the nearest preceding (parent) CIE </td></tr><tr> <td>Initial location  </td> <td>various bytes </td> <td>Reference to the function corresponding to the FDE </td></tr><tr> <td>Range length  </td> <td>various bytes </td> <td>Size of the function corresponding to the FDE </td></tr><tr> <td>Augmentation data length  </td> <td>unsigned LEB128 </td> <td>Present if CIE Augmentation is non-empty </td></tr><tr> <td>Instructions </td> <td>array of bytes </td> <td>Dwarf Call Frame Instructions </td></tr></tbody></table> <p>Here is an example of parsing a CIE and FDE (with a nice <a href="http://www.hexblog.com/wp-content/uploads/2012/06/recon-2012-skochinsky-scripts.zip">Skochinsky’s script</a> for IDA Pro). The sizes of the following CIE and FDE are 0x14 and 0x34 respectively. The FDE has a CIE pointer pointing to the parent CIE (at 0x4090A0). The function location corresponding to this FDE starts from 0x400c70 to 0x4010c0, whose size is 0x450.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CIE (Common Information Entry)
.eh_frame:0x04090A0 14 00 00 00     ; Size
.eh_frame:0x04090A4 00 00 00 00     ; CIE id
.eh_frame:0x04090A8 01              ; Version
.eh_frame:0x04090A9 7A 52 00        ; Augmentation String (aZr)
.eh_frame:0x04090AC 01              ; Code alignment factor
.eh_frame:0x04090AD 78              ; Data alignment factor
.eh_frame:0x04090AE 10              ; Return register
.eh_frame:0x04090AF 01              ; Augmentation data length
.eh_frame:0x04090B0 1B              ; R: FDE pointers encoding
.eh_frame:0x04090B1 0C 07 08 90+    ; Initial CFE Instructions

FDE (Frame Descriptor Entry)
.eh_frame:0x04090B8 34 00 00 00     ; Size
.eh_frame:0x04090BC 1C 00 00 00     ; CIE pointer (0x4090A0)
.eh_frame:0x04090C0 B0 7B FF FF     ; Initial location=0x400C70
.eh_frame:0x04090C4 50 04 00 00     ; Range length=0x450(end=0x4010C0)
.eh_frame:0x04090C8 00              ; Augmentation data length
.eh_frame:0x04090C9 41 0E 10 42+    ; CFE Instructions
...
</code></pre></div></div> <p><strong>b) .<em>eh_frame_hdr</em> section</strong></p> <p>The .<em>eh_frame_hdr</em> section contains a series of attributes, followed by the table of multiple pairs of (initial location, pointer to the FDE in the .<em>eh_frame</em>). The entries are sorted by functions that allows to perform a quick binary search of O(log n). </p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>version (uint8)            structure version (=1)
eh_frame_ptr_enc (uint8)   encoding of eh_frame_ptr
fde_count_enc (uint8)      encoding of fde_count
table_enc (uint8)          encoding of table entries
eh_frame_ptr (enc)         pointer to the start of the .eh_frame section
fde_count (enc)            number of entries in the table
----------------------- Table starts from here -------------------------
initial_loc[i]             initial location for the FDE
fde_ptr[i]                 corresponding FDE
------------------------------------------------------------------------
</code></pre></div></div> <p>The next figure is a brief illustration of the relationship of two sections.</p> <p><a href="http://dandylife.net/blog/archives/686/eh_frame"><img src="http://dandylife.net/blog/wp-content/uploads/2017/09/eh_frame.jpg" alt=""/></a></p> <p>Note that the attribute, <em>table_enc</em>, describes how the table has been encoded. It consists of lower 4 bits for value and upper 4 bits for encoding as follows: DWARF Exception Header value format (lower 4 bits) and DWARF Exception Header Encoding (upper 4 bits)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DW_EH_PE_omit	 0xff	No value is present
DW_EH_PE_uleb128 0x01	Unsigned value is encoded using LEB128
DW_EH_PE_udata2	 0x02	A 2 bytes unsigned value
DW_EH_PE_udata4	 0x03	A 4 bytes unsigned value
DW_EH_PE_udata8	 0x04	An 8 bytes unsigned value
DW_EH_PE_sleb128 0x09	Signed value is encoded using LEB128
DW_EH_PE_sdata2	 0x0A	A 2 bytes signed value
DW_EH_PE_sdata4	 0x0B	A 4 bytes signed value
DW_EH_PE_sdata8	 0x0C	An 8 bytes signed value

DW_EH_PE_absptr  0x00 Used with no modification 
DW_EH_PE_pcrel   0x10 Relative to the current program counter 
DW_EH_PE_datarel 0x30 Relative to the beginning of the .eh_frame_hdr 
DW_EH_PE_omit    0xff No value is present
</code></pre></div></div> <p><strong>References</strong><a href="https://refspecs.linuxfoundation.org/LSB_1.3.0/gLSB/gLSB/ehframehdr.html"><br/> https://refspecs.linuxfoundation.org/LSB_1.3.0/gLSB/gLSB/ehframehdr.htm<br/> </a><a href="http://www.dwarfstd.org/doc/DWARF4.pdf">http://www.dwarfstd.org/doc/DWARF4.pdf<br/> </a><a href="http://www.hexblog.com/wp-content/uploads/2012/06/Recon-2012-Skochinsky-Compiler-Internals.pdf">http://www.hexblog.com/wp-content/uploads/2012/06/Recon-2012-Skochinsky-Compiler-Internals.pdf<br/> </a><a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf<br/> </a></p>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Miscellaneous Stuff"/><summary type="html"><![CDATA[In ELF binary, there are two sections to support exception handling routines that are predominately used by C++ applications: .eh_frame and  .eh_frame_hdr. However, System V Application Binary Interface (ABI) for AMD64 mandates to have those sections even they are written in C.]]></summary></entry><entry><title type="html">Dynamic Linking in ELF</title><link href="https://kevinkoo001.github.io/blog/2016/dynamic-linking-in-elf/" rel="alternate" type="text/html" title="Dynamic Linking in ELF"/><published>2016-11-11T20:59:58+00:00</published><updated>2016-11-11T20:59:58+00:00</updated><id>https://kevinkoo001.github.io/blog/2016/dynamic-linking-in-elf</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2016/dynamic-linking-in-elf/"><![CDATA[<p>ELF is the binary format that allows for being both executable and linkable. It is de-facto standard in Linux.</p> <p><strong>A. Linking Overview</strong></p> <p>As the size of the program functionality grows, modulization helps programmers to maintain their code with efficiency. During compilation, an object file is generated per module. Afterwards, a linker (i.e., <em>ld</em> or <em>ld.gold</em>) takes one or more object files and combines them into a single executable file, library file, or another object file. A linker plays an pivotal role to resolve the locations like re-targeting absolute jumps.</p> <p>An object file contains a symbol - a primitive datatype to be identified - that references another object file in nature. There are two symbol kinds: local symbols and external symbols. A local symbol resides in the same object file (often for the relocation purpose at linking time). For the latter, if an external symbol is defined inside the object file it can be called from other modules. If undefined, it requires to find the symbol to which references. The referenced symbol can be located in either another object file or a library file, a collection of object files that can be shared by other executables.</p> <p>A library can be static or dynamic. If an application employs a symbol in a static library (.a extension), the compiler directly merges the object file that contains the symbol with a final executable. When the object file contains another symbol in another object file, it should be resolved and combined at compilation time as well although the object file is not required by the original program. In case of a dynamic library (shared object or .so extension), the final executable does not embed the object file. Instead, it delays the resolution of undefined symbols until runtime and lets a dynamic linker do its job. Hence, a statically linked executable can run itself without a library at runtime whereas a dynamically linked one cannot.</p> <p>Here we demystify how dynamic linking works with a simple example for the shared object or position independent code (-fPIC option in a gcc and clang) in x86_64 (AKA AMD64).</p> <p><strong>B. Sample Program</strong></p> <p>Here is a tiny source code that has two modules (<em>test.c</em> and <em>func.c</em>) and one header file (<em>func.h</em>). </p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// test.c
#include &lt;stdio.h&gt;
#include "func.h"

void calc(int x, int y) {
        printf("x + y = %d\n", add(x, y));
        printf("x - y = %d\n", sub(x, y));
}

int main(void) {
        int a = 10;
        int b = 7;
        calc(10, 7);
        return 0;
}

// func.c
#include "func.h"

int add(int x, int y) {
        int a = x;
        int b = y;
        return a + b;
}


int sub(int x, int y) {
        int a = x;
        int b = y;
        return a - b;
}

// func.h 
extern int add(int, int);
extern int sub(int, int);
extern void calc(int, int);

// Compile the files above with clang
// $ clang -o main func.c calc.c
</code></pre></div></div> <p><strong>C. ELF Header and Tables for Program Header and Section Header</strong></p> <p>ELF consists of three parts: ELF Header, Program Header Table and Section Header Table. </p> <p>First off, ELF header is quite self-explantionary with the defined struct itself in <em>Elf64_Ehdr</em>. See the comments below.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># define ELF_NIDENT      16
 
typedef struct {
        uint8_t         e_ident[ELF_NIDENT]; // ELF Identification: See [a]
        Elf32_Half      e_type;      // Object File Type: See [b]
        Elf32_Half      e_machine;   // Required Architecture
        Elf32_Word      e_version;   // Object Version
        Elf32_Addr      e_entry;     // Entry Point VA*
        Elf32_Off       e_phoff;     // Program Header Offset
        Elf32_Off       e_shoff;     // Section Header Offset
        Elf32_Word      e_flags;     // Processor-Specific Flags
        Elf32_Half      e_ehsize;    // ELF Header Size in Bytes
        Elf32_Half      e_phentsize; // Size of each Program Header Entry
        Elf32_Half      e_phnum;     // Number of Program Headers
        Elf32_Half      e_shentsize; // Size of each Section Header Entry
        Elf32_Half      e_shnum;     // Number of Section Headers
        Elf32_Half      e_shstrndx;  // Section Header String Table Index 
}
Elf64_Ehdr;

// [a] Elf_Ident Enum
enum Elf_Ident {
        EI_MAG0         = 0, // 0x7F
        EI_MAG1         = 1, // 'E'
        EI_MAG2         = 2, // 'L'
        EI_MAG3         = 3, // 'F'
        EI_CLASS        = 4, // Architecture (32/64)
        EI_DATA         = 5, // Byte Order: ELFDATA2LSB=0x1, ELFDATA2MSB=0x2
        EI_VERSION      = 6, // File Version
        EI_OSABI        = 7, // OS Specific
        EI_ABIVERSION   = 8, // OS Specific
        EI_PAD          = 9  // Padding (Unused)
};
 
# define ELFMAG0      0x7F // e_ident[EI_MAG0]
# define ELFMAG1      'E'  // e_ident[EI_MAG1]
# define ELFMAG2      'L'  // e_ident[EI_MAG2]
# define ELFMAG3      'F'  // e_ident[EI_MAG3]
# define ELFDATA2LSB  (1)  // Little Endian
# define ELFCLASS64   (1)  // 64-bit Architecture

// [b] Elf_type structure
enum Elf_Type {
        ET_NONE         = 0, // Unkown Type
        ET_REL          = 1, // Relocatable File
        ET_EXEC         = 2  // Executable File
        ET_DYN          = 3  // Shared Object File
        ET_CORE         = 4  // Core File
        ET_LOPROC       = 0xff00  // Processor-Specific
        ET_HIPROC       = 0xffff  // Processor-Specific 
};
</code></pre></div></div> <p>The program header table (PHT) describes how a loader maps the binary into virtual address space (or VA) when loading, whereas the section header table (SHT) has the entries of each defined section header when linking. Each mapped region in VA by a PHT entry is often called a segment from a loader view. As is a section by a SHT entry from a linker view.</p> <p>The final executable file <em>main</em> is shown as following (Figure 1). The linker view on the left shows how each section is stored as a file at offline. The loader view on the right shows how each segment is loaded as a process at runtime. For instance, [S1] is the first section whose size is 0x1c with (A)llocatable by a loader. R, X and W denote readable, executable and writable respectively. On a loader view, there are four major chucks of memory: 0x400000-0x401000 (RX), 0x401000-0x402000 (RW), regions for shared objects and the space for stack and heap.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Figure 1&gt;
                &lt;Linker View&gt;                               &lt;Loader View&gt;
                
FileOffset                                  VirtualAddr  LOAD (SZ=0x1000)
          .-----------------------------. ------------&gt; .------------------.
   0x0000 |  ELF Header                 |      0x400000 |  ELF_HDR (R)     |
          .-----------------------------.               |------------------|
   0x0040 |  Program Header Table       |      0x400040 |  PHDR (R)        |
          |                             |               |                  |
          |                             |               |                  |
          |                             |               |                  |
          |                             |               |                  |
          .-----------------------------.               |------------------|
   0x0200 | [S1] .interp (0x1c) A       |      0x400200 |  INTERP (R)      |
          .-----------------------------.               |------------------|
   0x021c | [S2] .note.ABI-tag (0x20) A |               |  (RX)            |
          .-----------------------------.               |                  |
   0x0240 | [S3] .dynsym (0xa8) A       |               |                  |
          .-----------------------------.               |                  |
   0x02e8 | [S4] .dynstr (0x89) A       |               |                  |
          .-----------------------------.               |                  |
   0x0378 | [S5] .hash (0x30) A         |               |                  |
          .-----------------------------.               |                  |
   0x03a8 | [S6] .gnu.version (0xe) A   |               |                  |
          .-----------------------------.               |                  |
   0x03b8 | [S7] .gnu.version_r (0x20) A|               |                  |
          .-----------------------------.               |                  |
   0x03d8 | [S8] .rela.dyn (0x18) A     |               |                  |
          .-----------------------------.               |                  |
   0x03f0 | [S9] .rela.plt (0x48) AI    |               |                  |
          .-----------------------------. ------------&gt; |------------------|
   0x0438 | [S10] .init (0x1a) AX       |               |                  |
          .-----------------------------.               |                  |
   0x0460 | [S11] .plt (0x40) AX        |               |                  |
          .-----------------------------.               |                  |
   0x04a0 | [S12] .text (0xa8) AX       |               |                  |
          |                             |               |                  |
          .-----------------------------.               |                  |
   0x06f4 | [S13] .fini (0x9) AX        |               |                  |
          .-----------------------------. ------------&gt; |------------------|
   0x0700 | [S14] .rodata (0x1c) AMS    |               |                  |
          .-----------------------------.               |                  |
   0x0720 | [S15] .eh_frame (0xd4) A    |               |                  |
          .-----------------------------.               |                  |
   0x07f4 | [S16] .eh_frame_hdr (0x2c) A|               |                  |
          .-----------------------------. ------------&gt; .------------------.
   0x0820 | [S17] .dynamic (0x1d) WA    |    |
          |                             |    |          LOAD (SZ=0x1000)
          .-----------------------------.    |          .------------------.
   0x09f0 | [S18] .got (0x8) WA         |    | 0x401000 |                  |
          .-----------------------------.    \--------&gt; .------------------.
   0x09f8 | [S19] .got.plt (0x30) WA    |      0x401820 |  (RW)            |
          .-----------------------------.               |                  |
   0x0a28 | [S20] .data (0x10) WA       |               |                  |
          .-----------------------------.               |                  |
   0x0a38 | [S21] .jcr (0x8) WA         |               |                  |
          .-----------------------------.               |                  |
   0x0a40 | [S22] .tm_clone_tbl (0x0)WA |               |                  |
          .-----------------------------.               |                  |
   0x0a40 | [S23] .fini_array (0x8) WA  |               |                  |
          .-----------------------------.               |                  |
   0x0a48 | [S24] .init_array (0x8) WA  |               |                  |
          .-----------------------------.               |                  |
   0x0a50 | [S25] .bss (0x4) WA         |      0x401a50 |                  |
          .-----------------------------. ---&gt; 0x402000 .------------------.
   0x0a50 | [S26] .comment (0x62) MS    | \
          .-----------------------------. |             .------------------.
   0x0ab4 | [S27] .note.gnu.gold (0x1c) | | 7ffff7a0e000|  Shared Objects  |
          .-----------------------------. |             |  libc, ld, ...   |
   0x0ad0 | [S28] .symtab (0x408)       | |             |                  |
          .-----------------------------. |             .------------------.
   0x0ed8 | [S29] .strtab (0x23f)       | | 
          .-----------------------------. | No mapping in a virtual address
   0x1117 | [S30] .shstrtab (0x118)     | |
          .-----------------------------. |             .------------------.
   0x1230 |  Section Header Table       | |             |  Heap            |
          |   Entry [S0] NULL           | |             |                  |
          |   Entry [S1] .interp        | |             |                  |
          |         .....               | | 7ffffffde000|  Stack           |
          |   Entry [S30] .shstrtab     | |             .------------------.
   0x19f0 .-----------------------------./
</code></pre></div></div> <p>A friendly ‘<em>readelf</em>’ command illustrates what each segment and section look like by reading the structure. Note that there are a lot of sections appended during compilation. </p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Section to Segment mapping:
Segment Sections...
00
01     .interp
02     .interp .note.ABI-tag .dynsym .dynstr .hash .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .eh_frame .eh_frame_hdr
03     .dynamic .got .got.plt .data .jcr .tm_clone_table .fini_array .init_array .bss
04     .dynamic
05     .note.ABI-tag
06     .eh_frame_hdr
07

// Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000400200  00000200
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.ABI-tag     NOTE             000000000040021c  0000021c
       0000000000000020  0000000000000000   A       0     0     4
  [ 3] .dynsym           DYNSYM           0000000000400240  00000240
       00000000000000a8  0000000000000018   A       4     1     8
  [ 4] .dynstr           STRTAB           00000000004002e8  000002e8
       0000000000000089  0000000000000000   A       0     0     1
  [ 5] .hash             HASH             0000000000400378  00000378
       0000000000000030  0000000000000004   A       3     0     8
  [ 6] .gnu.version      VERSYM           00000000004003a8  000003a8
       000000000000000e  0000000000000002   A       3     0     2
  [ 7] .gnu.version_r    VERNEED          00000000004003b8  000003b8
       0000000000000020  0000000000000000   A       4     1     4
  [ 8] .rela.dyn         RELA             00000000004003d8  000003d8
       0000000000000018  0000000000000018   A       3     0     8
  [ 9] .rela.plt         RELA             00000000004003f0  000003f0
       0000000000000048  0000000000000018  AI       3    11     8
  [10] .init             PROGBITS         0000000000400438  00000438
       000000000000001a  0000000000000000  AX       0     0     4
  [11] .plt              PROGBITS         0000000000400460  00000460
       0000000000000040  0000000000000010  AX       0     0     16
  [12] .text             PROGBITS         00000000004004a0  000004a0
       0000000000000252  0000000000000000  AX       0     0     16
  [13] .fini             PROGBITS         00000000004006f4  000006f4
       0000000000000009  0000000000000000  AX       0     0     4
  [14] .rodata           PROGBITS         0000000000400700  00000700
       000000000000001c  0000000000000000 AMS       0     0     4
  [15] .eh_frame         PROGBITS         0000000000400720  00000720
       00000000000000d4  0000000000000000   A       0     0     8
  [16] .eh_frame_hdr     PROGBITS         00000000004007f4  000007f4
       000000000000002c  0000000000000000   A       0     0     4
  [17] .dynamic          DYNAMIC          0000000000401820  00000820
       00000000000001d0  0000000000000010  WA       4     0     8
  [18] .got              PROGBITS         00000000004019f0  000009f0
       0000000000000008  0000000000000000  WA       0     0     8
  [19] .got.plt          PROGBITS         00000000004019f8  000009f8
       0000000000000030  0000000000000000  WA       0     0     8
  [20] .data             PROGBITS         0000000000401a28  00000a28
       0000000000000010  0000000000000000  WA       0     0     8
  [21] .jcr              PROGBITS         0000000000401a38  00000a38
       0000000000000008  0000000000000000  WA       0     0     8
  [22] .tm_clone_table   PROGBITS         0000000000401a40  00000a40
       0000000000000000  0000000000000000  WA       0     0     8
  [23] .fini_array       FINI_ARRAY       0000000000401a40  00000a40
       0000000000000008  0000000000000000  WA       0     0     8
  [24] .init_array       INIT_ARRAY       0000000000401a48  00000a48
       0000000000000008  0000000000000000  WA       0     0     8
  [25] .bss              NOBITS           0000000000401a50  00000a50
       0000000000000004  0000000000000000  WA       0     0     4
  [26] .comment          PROGBITS         0000000000000000  00000a50
       0000000000000062  0000000000000001  MS       0     0     1
  [27] .note.gnu.gold-ve NOTE             0000000000000000  00000ab4
       000000000000001c  0000000000000000           0     0     4
  [28] .symtab           SYMTAB           0000000000000000  00000ad0
       0000000000000408  0000000000000018          29    22     8
  [29] .strtab           STRTAB           0000000000000000  00000ed8
       000000000000023f  0000000000000000           0     0     1
  [30] .shstrtab         STRTAB           0000000000000000  00001117
       0000000000000118  0000000000000000           0     0     1

Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)
</code></pre></div></div> <p><strong>D.  Linking process</strong></p> <p>Before moving on, here is what the object looks like (in <em>crt1.o</em>). The relocation record shows that there are four locations that cannot be resolved while compilation process. That is why the 4-byte address is empty filled with 0x0s. The first relocation entry at offset 12 has the reference of <em>__libc_csu_fini</em>, defined in another object. We can see that <em>_start</em> function actually calls our <em>main</em> function at offset 0x20, the entry point of the final executable.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0000000000000000 &lt;_start&gt;:
   0:   31 ed                   xor    ebp,ebp
   2:   49 89 d1                mov    r9,rdx
   5:   5e                      pop    rsi
   6:   48 89 e2                mov    rdx,rsp
   9:   48 83 e4 f0             and    rsp,0xfffffffffffffff0
   d:   50                      push   rax
   e:   54                      push   rsp
   f:   49 c7 c0 00 00 00 00    mov    r8,0x0
  16:   48 c7 c1 00 00 00 00    mov    rcx,0x0
  1d:   48 c7 c7 00 00 00 00    mov    rdi,0x0
  24:   e8 00 00 00 00          call   29 &lt;_start+0x29&gt;
  29:   f4                      hlt

RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE
0000000000000012 R_X86_64_32S      __libc_csu_fini
0000000000000019 R_X86_64_32S      __libc_csu_init
0000000000000020 R_X86_64_32S      main
0000000000000025 R_X86_64_PC32     __libc_start_main-0x0000000000000004
</code></pre></div></div> <p>Now, when the given program is compiled by default, <em>gcc</em> or <em>clang</em> driver combines necessary files (i.e., CRT) to allow a loader to handle it properly.  The Figure 2 illustrates them. (*) means the function is defined in the object file, whereas others are declared outside of the file. (i.e., using <em>extern</em> keyword in C) For example, crt1.o defines <em>_start _in the file  but the function ___libc_start_main</em> has to be resolved in a linking time (or maybe later).</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Figure 2&gt;
.-------------------.-----------------------.---------------------------.----------.
| crt1.o            | cri.o                 | crtbegin.o                | crtn.o   |
.-------------------|-----------------------|---------------------------.----------.
| _start*           | __init*               | deregister_tm_clones *    | .init    |
| __libc_csu_fini   | __fini*               | register_tm_clones *      | .fini    |
| __libc_csu_init   | __gmon_start          | __do_global_dtors_aux *   |          |
| __libc_start_main | _GLOBAL_OFFSET_TABLE_ | frame_dummy *             |          |
|                   |                       | __TMC_END__               |          |
|                   |                       | _ITM_deregisterTMCloneTab |          |
|                   |                       | _ITM_registerTMCloneTable |          |
|                   |                       | _Jv_RegisterClasses       |          |
.-------------------------------------------.---------------------------.----------.
| libc.a                         | crtend.o | func.o                    | test.o   |
.--------------------------------.----------.---------------------------.----------.
| __libc_csu_fini (elf-init.o) * | NONE     | add *                     | calc *   |
| __libc_csu_init (elf-init.o) * |          | sub *                     | main *   |
| printf (printf.o) *            |          |                           | add      |
|                                |          |                           | printf   |
|                                |          |                           | sub      |
.--------------------------------.----------.---------------------------.----------.
</code></pre></div></div> <p>Let’s see the layout of all functions from each object file. Figure 3 is part of sections from 10 to 13 in Figure 1. Interesting enough, the layout of all functions in a single object file is not inter-mixed.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Figure 3&gt;
         |          ...           |
         |========================|
   .init | _init_proc             |  __init (cri.o) + .init (crtn.o)
         |========================|
   .plt  | __libc_start_main      | \ The addresses will be resolved 
         | __gmon_start__         | | at runtime by dynamic linker,
         | _printf                | | the .plt entry is fixed up 
         |========================| / when each function is invoked.
   .text | _start                 |   crt1.o
         |------------------------| \
         | deregister_tm_clones   | |
         | register_tm_clones     | | crtbegin.o
         | __do_global_dtors_aux  | |
         | frame_dummy            | |
         |------------------------| /
         | calc                   | \
         | main                   | | test.o
         |------------------------| /
         | add                    | \
         | sub                    | | func.o
         |------------------------| /
         | __libc_csu_init        | \
         | __libc_csu_fini        | | libc.a (included in a binary)
         |========================| /
    .fini| _term_proc             | __fini (cri.o) + .fini (crtn.o)
         |========================|
         |          ...           |
</code></pre></div></div> <p><strong>E. Dynamic Linking</strong></p> <p>When dynamic linking is required (modern compiler set it by default), a compiler generates .<em>dynamic</em> section (section index 17 above). Note that executable files and shared object files have a separate procedure linkage table (PLT).</p> <p>With the sample we have, the dynamic section contains 24 entries as following. Pay attention to the highlighted, which are required by dynamic linker. The section .<em>plt.got (PLTGOT)</em> is the very place that the final fix-ups are stored by dynamic linker. The <em>.rela.plt</em> (JMPREL) and <em>.rela.dyn</em> (RELA) are the relocation section tables that describe relocation entries.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Dynamic section at offset 0x820 contains 24 entries:
  Tag        Type                    Name/Value
 0x0000000000000003 (PLTGOT)        0x4019f8      // address of .plt.got section
 0x0000000000000002 (PLTRELSZ)      72 (bytes)    // size of .plt.got section
 0x0000000000000017 (JMPREL)        0x4003f0      // address of .rela.plt section
 0x0000000000000014 (PLTREL)        RELA          // relocation type (REL / RELA)
 0x0000000000000007 (RELA)          0x4003d8      // address of .rela.dyn section
 0x0000000000000008 (RELASZ)        24 (bytes)    // total size of .rela.dyn section
 0x0000000000000009 (RELAENT)       24 (bytes)    // size of an entry in .rela.dyn section
 0x0000000000000015 (DEBUG)         0x0
 0x0000000000000006 (SYMTAB)        0x400240      // address of .symtab section
 0x000000000000000b (SYMENT)        24 (bytes)    // size of an entry in .symtab section
 0x0000000000000005 (STRTAB)        0x4002e8      // address of .strtab section
 0x000000000000000a (STRSZ)         137 (bytes)   // size of .strtab section
 0x0000000000000004 (HASH)          0x400378      // address of hash section
 0x0000000000000001 (NEEDED)        Shared library: [libc.so.6] 
 0x000000000000000c (INIT)          0x400438      // address of .init section
 0x000000000000000d (FINI)          0x4006f4      // address of .fini section
 0x000000000000001a (FINI_ARRAY)    0x401a40      // address of .fini_array section
 0x000000000000001c (FINI_ARRAYSZ)  8 (bytes)     // size of ._fini_array
 0x0000000000000019 (INIT_ARRAY)    0x401a48      // address of .init_array section
 0x000000000000001b (INIT_ARRAYSZ)  8 (bytes)     // size of ._fini_array
 0x000000006ffffff0 (VERSYM)        0x4003a8      // address of .gnu.version section
 0x000000006ffffffe (VERNEED)       0x4003b8      // address of .gnu.version_r section
 0x000000006fffffff (VERNEEDNUM)    1             // number of needed versions
 0x0000000000000000 (NULL)          0x0           // end of .dynamic section
</code></pre></div></div> <p>Here are the symbols in relocation sections. The type “<em>R_X86_64_JUMP_SLOT</em>” means these symbols need to be resolved at runtime by dynamic linker. The offset is the location that resolved reference has to be stored.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Relocation section '.rela.dyn' at offset 0x3d8 contains 1 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
0000004019f0  000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0

Relocation section '.rela.plt' at offset 0x3f0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000401a10  000200000007 R_X86_64_JUMP_SLO 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
000000401a18  000300000007 R_X86_64_JUMP_SLO 0000000000000000 __gmon_start__ + 0
000000401a20  000100000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0
</code></pre></div></div> <p>The Figure 4 (before resolution) and 5 (after resolution) illustrate how dynamic linker resolves the references on the fly. With disassembly, three symbols are called at 0x400448, 0x4004c4 and 0x4005c7. At first, they are supposed to jump to somewhere in PLT. Again, another jump instruction in PLT corresponds to somewhere in a <em>.got.plt</em>. The value in <em>.got.plt</em> has the address of next instruction in <em>.plt</em> that has pointed to itself (+6).</p> <p>For example, the address of <em>printf@plt</em> is 0x400490, and it jumps to 0x400496 after dereferencing (rip+0x158a is 0x401a20, and 0x400496 is stored in there). Then it pushes 0x2 and jumps to <em>.plt</em> table.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Figure 4&gt;

      .text                           .plt &lt;--------------------------------------\
      .-------------------.           .---------------------------.               |
4004a0|                   |     400460|   pushq [rip+0x159a]      | &lt;_GOT+8&gt;      |
      |                   |           |---------------------------|               |
      |                   |           |   jmpq  [rip+0x159c]      | &lt;_GOT+16&gt;     |
      |-------------------|           |---------------------------|               |
400448| call &lt;__gmon_     |     400470|   jmpq  [rip+0x159a]      | &lt;__libc_..@ --|--\
      |  start__@plt&gt;     | /-------&gt; |   push  0x0               |  got.plt&gt;     |  |
      |-------------------| |         |   jmp   0x400460          | --------------|  |
      |-------------------| |         |---------------------------|               |  |
4004c4| call &lt;__libc_     | |   400480|   jmpq  [rip+0x1592]      | &lt;__gmon_..@ --|--|--\
      |  start_main@plt&gt;  | | /-----&gt; |   push  0x1               |  got.plt      |  |  |
      |-------------------| | |       |   jmp   0x400460          |---------------|  |  |
      |-------------------| | |       |---------------------------|               |  |  |
4005c7| call &lt;printf@plt&gt; | | | 400490|   jmpq  [rip+0x158a]      | &lt;printf@ -----|--------\
      |-------------------| | | /---&gt; |   push  0x2               |  got.plt&gt;     |  |  |  |
      |                   | | | |     |   jmp   0x400460          | -------------/   |  |  |
      |                   | | | |     .---------------------------.                  |  |  |
      |                   | | | |       &lt;Procedure Linkage Table&gt;                    |  |  |
      |                   | | | |                                                    |  |  |
      |                   | | | |     .got                                           |  |  |
      .-------------------. | | |     .---------------------------.                  |  |  |
                            | | |     |            0x0            |4019f0            |  |  |
      .got.plt sec_hdr      | | |     |---------------------------|                  |  |  |
      .-------------------. | | |     |   (.dynamic) 0x0401820    |4019f8            |  |  |
      | PLTGOT            | | | |     .---------------------------.                  |  |  |
      |                   | | | |          &lt;Global Offset Table&gt;                     |  |  |
      |                   | | | |                                                    |  |  |
      |                   | | | |                                                    |  |  |
      |                   | | | |     .got.plt                                       |  |  |
      |                   | | | |     .---------------------------.                  |  |  |
      .-------------------. | | |     |           0x0             |401a00            |  |  |
                            | | |     |           0x0             |401a08            |  |  |
      .rela.plt sec_hdr     \-|-|---- |         0x400476          |401a10 &lt;----------/  |  |
      .-------------------.   \-|---- |         0x400486          |401a18 &lt;-------------/  |
      | JMPREL            |     \---- |         0x400496          |401a20 &lt;----------------/
      |   r_offset        |           .---------------------------.
      |   r_info          | &lt;-- R_X86_64_JUMP_SLO type
      |   r_addend        |           
      .-------------------.      
</code></pre></div></div> <p>Here is the snapshot after the resolution of <strong><em>libc_start_main</em> and <em>printf</em> at <em>glibc</em>. The code for </strong><em>gmon_start</em>__ is already in the final executable. (thus 0x400486). At this point, all references are successfully resolved by dynamic linker. Note that the reference is resolved only once when it is called for the first time. </p> <p>The address of the routine for the resolution is stored at 0x401a08, which is <em>dl_runtime_resolve_avx</em> in this example.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Figure 5&gt;
      .text                               .plt &lt;--------------------------------------\
      .-------------------.               .---------------------------.               |
4004a0|                   |         400460|   pushq [rip+0x159a]      | &lt;_GOT+8&gt;      |
      |                   |               |---------------------------|               |
      |                   |               |   jmpq  [rip+0x159c]      | &lt;_GOT+16&gt;     |
      |-------------------|               |---------------------------|               |
400448| call &lt;__gmon_     |  /----&gt; 400470|   jmpq  [rip+0x159a]      | &lt;__libc_..@ --|--\
      |  start__@plt&gt;     |--|\           |   push  0x0               |  got.plt&gt;     |  |
      |-------------------|  ||           |   jmp   0x400460          | --------------|  |
      |-------------------|  ||           |---------------------------|               |  |
4004c4| call &lt;__libc_     | -/\---&gt; 400480|   jmpq  [rip+0x1592]      | &lt;__gmon_..@ --|--|--\
      |  start_main@plt&gt;  |               |   push  0x1               |  got.plt      |  |  |
      |-------------------|               |   jmp   0x400460          |---------------|  |  |
      |-------------------|               |---------------------------|               |  |  |
4005c7| call &lt;printf@plt&gt; | ------&gt; 400490|   jmpq  [rip+0x158a]      | &lt;printf@ -----|--------\
      |-------------------|               |   push  0x2               |  got.plt&gt;     |  |  |  |
      |                   |               |   jmp   0x400460          | -------------/   |  |  |
      |                   |               .---------------------------.                  |  |  |
      |                   |                 &lt;Procedure Linkage Table&gt;                    |  |  |
      |                   |                                                              |  |  |
      |                   |               .got                                           |  |  |
      .-------------------.               .---------------------------.                  |  |  |
                                          |            0x0            |4019f0            |  |  |
      .got.plt sec_hdr                    |---------------------------|                  |  |  |
      .-------------------.               |    (.dynamic) 0x0401820   |4019f8            |  |  |
      | PLTGOT            |               .---------------------------.                  |  |  |
      |                   |                    &lt;Global Offset Table&gt;                     |  |  |
      |                   |                                                              |  |  |
      |                   |           /-- [dl_runtime_resolve_avx] &lt;------------\        |  |  |
      |                   |           |   .got.plt                              |        |  |  |
      |                   |           \-&gt; .---------------------------.         |        |  |  |
      .-------------------.               |    0x00007ffff7ffe168     |401a00   |        |  |  |
                                          |    0x00007ffff7dee6a0     |401a08 --/        |  |  |
      .rela.plt sec_hdr                   |    0x00007ffff7a2e740     |401a10 &lt;----------/  |  |
      .-------------------.               |    0x0000000000400486     |401a18 &lt;-------------/  |
      | JMPREL            |               |    0x00007ffff7a637b0     |401a20 &lt;----------------/
      |   r_offset        |               .---------------------------.
      |   r_info          |     &lt;-- R_X86_64_JUMP_SLO type
      |   r_addend        |               
      .-------------------.                   
</code></pre></div></div> <p>For more curious readers, here are the source files from glibc that defines <em>__dl_runtime_resolve</em> and <em>_dl_fixup</em> internally. With several breakpoints in debugging, the routine stores the <em>link_map</em> at <em>%rdi</em> register and the <em>reloc_index</em> at <em>%rsi</em> register. This index is the very one pushed in <em>.plt</em> section.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define __dl_runtime_resolve at sysdeps/i386/dl-trampoline.S in the glibc-2.24
In sysdeps/x86_64/dl-trampoline.h, line 64
        # Copy args pushed by PLT in register.
        # %rdi: link_map, %rsi: reloc_index
        mov (LOCAL_STORAGE_AREA + 8)(%BASE), %RSI_LP (a)
        mov LOCAL_STORAGE_AREA(%BASE), %RDI_LP (b)
        call _dl_fixup          # Call resolver. (c)
        mov %RAX_LP, %R11_LP    # Save return value (d)
        
In sysdeps/elf/dl-runtime.c, line 66
    DL_FIXUP_VALUE_TYPE _dl_fixup (
           # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS 
           ELF_MACHINE_RUNTIME_FIXUP_ARGS, # endif
           struct link_map *l, ElfW(Word) reloc_arg) 

gdb-peda$ x/30i 0x00007ffff7dee6a0
   0x7ffff7dee6a0 &lt;_dl_runtime_resolve_avx&gt;:    push   rbx
   0x7ffff7dee6a1 &lt;_dl_runtime_resolve_avx+1&gt;:  mov    rbx,rsp
   0x7ffff7dee6a4 &lt;_dl_runtime_resolve_avx+4&gt;:  and    rsp,0xffffffffffffffe0
   0x7ffff7dee6a8 &lt;_dl_runtime_resolve_avx+8&gt;:  sub    rsp,0x180
   0x7ffff7dee6af &lt;_dl_runtime_resolve_avx+15&gt;: mov    QWORD PTR [rsp+0x140],rax
   0x7ffff7dee6b7 &lt;_dl_runtime_resolve_avx+23&gt;: mov    QWORD PTR [rsp+0x148],rcx
   0x7ffff7dee6bf &lt;_dl_runtime_resolve_avx+31&gt;: mov    QWORD PTR [rsp+0x150],rdx
   0x7ffff7dee6c7 &lt;_dl_runtime_resolve_avx+39&gt;: mov    QWORD PTR [rsp+0x158],rsi
   0x7ffff7dee6cf &lt;_dl_runtime_resolve_avx+47&gt;: mov    QWORD PTR [rsp+0x160],rdi
   0x7ffff7dee6d7 &lt;_dl_runtime_resolve_avx+55&gt;: mov    QWORD PTR [rsp+0x168],r8
   0x7ffff7dee6df &lt;_dl_runtime_resolve_avx+63&gt;: mov    QWORD PTR [rsp+0x170],r9
   0x7ffff7dee6e7 &lt;_dl_runtime_resolve_avx+71&gt;: vmovdqa YMMWORD PTR [rsp],ymm0
   0x7ffff7dee6ec &lt;_dl_runtime_resolve_avx+76&gt;: vmovdqa YMMWORD PTR [rsp+0x20],ymm1
   0x7ffff7dee6f2 &lt;_dl_runtime_resolve_avx+82&gt;: vmovdqa YMMWORD PTR [rsp+0x40],ymm2
   0x7ffff7dee6f8 &lt;_dl_runtime_resolve_avx+88&gt;: vmovdqa YMMWORD PTR [rsp+0x60],ymm3
   0x7ffff7dee6fe &lt;_dl_runtime_resolve_avx+94&gt;: vmovdqa YMMWORD PTR [rsp+0x80],ymm4
   0x7ffff7dee707 &lt;_dl_runtime_resolve_avx+103&gt;:        vmovdqa YMMWORD PTR [rsp+0xa0],ymm5
   0x7ffff7dee710 &lt;_dl_runtime_resolve_avx+112&gt;:        vmovdqa YMMWORD PTR [rsp+0xc0],ymm6
   0x7ffff7dee719 &lt;_dl_runtime_resolve_avx+121&gt;:        vmovdqa YMMWORD PTR [rsp+0xe0],ymm7
   0x7ffff7dee722 &lt;_dl_runtime_resolve_avx+130&gt;:        bndmov [rsp+0x100],bnd0
   0x7ffff7dee72b &lt;_dl_runtime_resolve_avx+139&gt;:        bndmov [rsp+0x110],bnd1
   0x7ffff7dee734 &lt;_dl_runtime_resolve_avx+148&gt;:        bndmov [rsp+0x120],bnd2
   0x7ffff7dee73d &lt;_dl_runtime_resolve_avx+157&gt;:        bndmov [rsp+0x130],bnd3
   0x7ffff7dee746 &lt;_dl_runtime_resolve_avx+166&gt;:        mov    rsi,QWORD PTR [rbx+0x10]
   0x7ffff7dee74a &lt;_dl_runtime_resolve_avx+170&gt;:        mov    rdi,QWORD PTR [rbx+0x8]
   0x7ffff7dee74e &lt;_dl_runtime_resolve_avx+174&gt;:        call   0x7ffff7de6820 &lt;_dl_fixup&gt;
   0x7ffff7dee753 &lt;_dl_runtime_resolve_avx+179&gt;:        mov    r11,rax
   0x7ffff7dee756 &lt;_dl_runtime_resolve_avx+182&gt;:        bndmov bnd3,[rsp+0x130]
   0x7ffff7dee75f &lt;_dl_runtime_resolve_avx+191&gt;:        bndmov bnd2,[rsp+0x120]
   0x7ffff7dee768 &lt;_dl_runtime_resolve_avx+200&gt;:        bndmov bnd1,[rsp+0x110]

gdb-peda$ x/30i 0x7ffff7de6820
   0x7ffff7de6820 &lt;_dl_fixup&gt;:  push   rbx
   0x7ffff7de6821 &lt;_dl_fixup+1&gt;:        mov    r10,rdi
   0x7ffff7de6824 &lt;_dl_fixup+4&gt;:        mov    esi,esi
   0x7ffff7de6826 &lt;_dl_fixup+6&gt;:        lea    rdx,[rsi+rsi*2]
   0x7ffff7de682a &lt;_dl_fixup+10&gt;:       sub    rsp,0x10
   0x7ffff7de682e &lt;_dl_fixup+14&gt;:       mov    rax,QWORD PTR [rdi+0x68] // 69 l_info[DT_STRTAB]
   0x7ffff7de6832 &lt;_dl_fixup+18&gt;:       mov    rdi,QWORD PTR [rax+0x8]  // 69 [rdi = strtab] const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
   0x7ffff7de6836 &lt;_dl_fixup+22&gt;:       mov    rax,QWORD PTR [r10+0xf8] // 72 (D_PTR (l, l_info[DT_JMPREL])
   0x7ffff7de683d &lt;_dl_fixup+29&gt;:       mov    rax,QWORD PTR [rax+0x8]  // 72 const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset)
   0x7ffff7de6841 &lt;_dl_fixup+33&gt;:       lea    r8,[rax+rdx*8] 
   0x7ffff7de6845 &lt;_dl_fixup+37&gt;:       mov    rax,QWORD PTR [r10+0x70] // 68 (const void *) D_PTR (l, l_info[DT_SYMTAB])
   0x7ffff7de6849 &lt;_dl_fixup+41&gt;:       mov    rcx,QWORD PTR [r8+0x8]   // 73 reloc-&gt;r_info
   0x7ffff7de684d &lt;_dl_fixup+45&gt;:       mov    rax,QWORD PTR [rax+0x8]  // 73 const &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]
   0x7ffff7de6851 &lt;_dl_fixup+49&gt;:       mov    rdx,rcx  // 73 const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]
   0x7ffff7de6854 &lt;_dl_fixup+52&gt;:       shr    rdx,0x20 // 73
   0x7ffff7de6858 &lt;_dl_fixup+56&gt;:       lea    rsi,[rdx+rdx*2] // 73
   0x7ffff7de685c &lt;_dl_fixup+60&gt;:       lea    rsi,[rax+rsi*8] // 73 [rsi = sym, 0x400270]
   0x7ffff7de6860 &lt;_dl_fixup+64&gt;:       mov    rax,QWORD PTR [r10] // 74 
   0x7ffff7de6863 &lt;_dl_fixup+67&gt;:       mov    QWORD PTR [rsp+0x8],rsi // 73
   0x7ffff7de6868 &lt;_dl_fixup+72&gt;:       mov    rbx,rax // 74
   0x7ffff7de686b &lt;_dl_fixup+75&gt;:       add    rbx,QWORD PTR [r8] // 74 void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);
   0x7ffff7de686e &lt;_dl_fixup+78&gt;:       cmp    ecx,0x7 // 79
   0x7ffff7de6871 &lt;_dl_fixup+81&gt;:       jne    0x7ffff7de69c7 &lt;_dl_fixup+423&gt; // 79
   0x7ffff7de6877 &lt;_dl_fixup+87&gt;:       test   BYTE PTR [rsi+0x5],0x3
   0x7ffff7de687b &lt;_dl_fixup+91&gt;:       jne    0x7ffff7de6919 &lt;_dl_fixup+249&gt;
   0x7ffff7de6881 &lt;_dl_fixup+97&gt;:       mov    rax,QWORD PTR [r10+0x1c8]
</code></pre></div></div> <p>[References]</p> <p><a href="http://www.skyfree.org/linux/references/ELF_Format.pdf">http://www.skyfree.org/linux/references/ELF_Format.pdf</a><br/> <a href="https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf">https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf<br/> </a><a href="https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=elf/elf.h">https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=elf/elf.h<br/> </a><a href="https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=elf/dl-reloc.c">https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=elf/dl-reloc.c<br/> </a><a href="http://www.cs.stevens.edu/~jschauma/810/elf.html">http://www.cs.stevens.edu/~jschauma/810/elf.html</a></p>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Miscellaneous Stuff"/><summary type="html"><![CDATA[ELF is the binary format that allows for being both executable and linkable. It is de-facto standard in Linux.]]></summary></entry><entry><title type="html">Cyber Grand Challenge by DARPA</title><link href="https://kevinkoo001.github.io/blog/2016/cyber-grand-challenge-by-darpa/" rel="alternate" type="text/html" title="Cyber Grand Challenge by DARPA"/><published>2016-07-31T07:58:36+00:00</published><updated>2016-07-31T07:58:36+00:00</updated><id>https://kevinkoo001.github.io/blog/2016/cyber-grand-challenge-by-darpa</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2016/cyber-grand-challenge-by-darpa/"><![CDATA[<p><strong>1. Overview</strong></p> <p>2014년 여름, 미 국방성 연구부문을 담당하고 있는 DARPA (Defense Advanced Research Projects Agency)에서 매우 흥미로운 competition event를 진행한다. 이름하여 Cyber Grand Challenge - 자동화된 공격방어 시스템 (automated cyber reasoning system) 하에 상호 간의 공격과 방어를 모두 기계가 실시간으로 담당하게 해 경쟁하는 대회다.</p> <p>많은 CTF Challenge 대회가 있지만, 사람의 개입없이 순수히 기계만을 이용해 취약점을 찾고, 공격과 방어를 하는 경우는 세계적으로 처음이었다. 게다가 상당히 큰 금액의 상금은 보안인의 관심을 끌기에 충분했다. </p> <p>대표링크는 <a href="https://cgc.darpa.mil">여기 https://cgc.darpa.mil</a> 로 각종 문서와 대회결과를 확인할 수 있다. 대회는 3년간 예선(2014년)과 최종후보 결선전(2015년)을 거쳐 2016년 8월 4일 DEF CON에서 Final 결승전을 치룬다. Final은 7개의 팀이 겨룰 예정이며, 우승자는 무려 20만불의 상금을 거머쥘 수 있다.</p> <p>작년 USENIX technical session에서 Invite Talk으로 DARPA의 Mike가 두번의 대회를 치르면서 있었던 과정과 결과를 발표했다. 발표자료는 <a href="https://www.usenix.org/sites/default/files/conference/protected-files/sec15_slides_walker.pdf">여기</a>를 참고하기 바란다. </p> <p><strong>UPDATED  (As of Aug. 8, 2016) </strong><br/> a. <a href="http://www.darpa.mil/news-events/2016-08-04"><em>Mayhem</em> declared the final winner of historic Cyber Grand Challenge</a>.<br/> b. Mayhem has been developed as a cyber reasoning system since 2012 by Sang Kil Cha et al., see the paper, <a href="https://users.ece.cmu.edu/~dbrumley/pdf/Cha%20et%20al._2012_Unleashing%20Mayhem%20on%20Binary%20Code.pdf">Unleashing MAYHEM on Binary Code</a>, for more details)<a href="http://repo.cybergrandchallenge.com/cfe/"><br/> </a>c. <a href="http://repo.cybergrandchallenge.com/cfe/">CFE File Archive</a> is available now.</p> <p><strong>2. DECREE </strong></p> <p>무엇보다도 DARPA는 취약점 자체에 초점을 맞출 수 있도록 기존 리눅스 환경을 변형한 DECREE라는 운영제체를 개발했다. DECREE는 수백 개의 system call이 존재하는 리눅스와는 다르게 실행파일이 다음과 같이 단 7개의 system call만을 이용하도록 설계했다. (<a href="https://github.com/CyberGrandChallenge/libcgc/blob/master/libcgc.h">Header 파일 참조</a>)</p> <ul> <li>int transmit(int fd, const void *buf, size_t count, size_t *tx_bytes);</li> <li>int receive(int fd, void *buf, size_t count, size_t *rx_bytes);</li> <li>int fdwait(int nfds, fd_set *readfds, fd_set *writefds);</li> <li>int allocate(size_t length, int is_X, void **addr);</li> <li>int deallocate(void *addr, size_t length);</li> <li>int random(void *buf, size_t count, size_t *rnd_bytes);</li> </ul> <p>새로운 운영체제에서 작동할 수 있는 실행파일을 컴파일할 수 있도록 gcc를 수정하고, 실행파일포맷 또한 기존의 ELF를 기반으로 한 cgc 포맷을 새로 정의했다. 이는 기존의 어떤 운영체제에서도 파일의 실행은 물론 대회에서 발견한 취약점과 exploit 모두 무미의함을 의미한다. 그리고 IPC (Inter-Process Communication) 도 무척 제한적이다. 공유 메모리를 지원하지 않으며, 단순한 양방향 통신만을 지원한다.</p> <p><a href="https://github.com/CyberGrandChallenge/cgc-release-documentation/blob/master/walk-throughs/running-the-vm.md">CyberGrandChallenge Github</a>에 있는 walk-through 문서를 따라 VirtualBox와 vagrant를 설치하고 vbox를 추가한 후 다음과 같이 5개의 VM을 차례로 부팅할 수 있다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Repos/cgc $ vagrant up
Bringing machine 'cb' up with 'virtualbox' provider...
Bringing machine 'ids' up with 'virtualbox' provider...
Bringing machine 'pov' up with 'virtualbox' provider...
Bringing machine 'crs' up with 'virtualbox' provider...
Bringing machine 'ti' up with 'virtualbox' provider...
[cb] Clearing any previously set forwarded ports...
[cb] Clearing any previously set network interfaces...
[cb] Preparing network interfaces based on configuration...
[cb] Forwarding ports...
[cb] -- 22 =&gt; 2222 (adapter 1)
[cb] Running 'pre-boot' VM customizations...
[cb] Booting VM...
[cb] Waiting for machine to boot. This may take a few minutes...
[cb] Machine booted and ready!
[cb] Setting hostname...
[cb] Configuring and enabling network interfaces...
[cb] Mounting shared folders...
[cb] -- /vagrant
[cb] VM already provisioned. Run `vagrant provision` or use `--provision` to force it
[ids] Clearing any previously set forwarded ports...
[ids] Fixed port collision for 22 =&gt; 2222. Now on port 2200.
[ids] Clearing any previously set network interfaces...
[ids] Preparing network interfaces based on configuration...
[ids] Forwarding ports...
[ids] -- 22 =&gt; 2200 (adapter 1)
[ids] Running 'pre-boot' VM customizations...
[ids] Booting VM...
[ids] Waiting for machine to boot. This may take a few minutes...
[ids] Machine booted and ready!
[ids] Setting hostname...
[ids] Configuring and enabling network interfaces...
[ids] Mounting shared folders...
[ids] -- /vagrant
[ids] VM already provisioned. Run `vagrant provision` or use `--provision` to force it
[pov] Clearing any previously set forwarded ports...
[pov] Fixed port collision for 22 =&gt; 2200. Now on port 2201.
[pov] Clearing any previously set network interfaces...
[pov] Preparing network interfaces based on configuration...
[pov] Forwarding ports...
[pov] -- 22 =&gt; 2201 (adapter 1)
[pov] Running 'pre-boot' VM customizations...
[pov] Booting VM...
[pov] Waiting for machine to boot. This may take a few minutes...
[pov] Machine booted and ready!
[pov] Setting hostname...
[pov] Configuring and enabling network interfaces...
[pov] Mounting shared folders...
[pov] -- /vagrant
[pov] VM already provisioned. Run `vagrant provision` or use `--provision` to force it
[crs] Clearing any previously set forwarded ports...
[crs] Fixed port collision for 22 =&gt; 2201. Now on port 2202.
[crs] Clearing any previously set network interfaces...
[crs] Preparing network interfaces based on configuration...
[crs] Forwarding ports...
[crs] -- 22 =&gt; 2202 (adapter 1)
[crs] Running 'pre-boot' VM customizations...
[crs] Booting VM...
[crs] Waiting for machine to boot. This may take a few minutes...
[crs] Machine booted and ready!
[crs] Setting hostname...
[crs] Configuring and enabling network interfaces...
[crs] Mounting shared folders...
[crs] -- /vagrant
[crs] VM already provisioned. Run `vagrant provision` or use `--provision` to force it
[ti] Clearing any previously set forwarded ports...
[ti] Fixed port collision for 22 =&gt; 2202. Now on port 2203.
[ti] Clearing any previously set network interfaces...
[ti] Preparing network interfaces based on configuration...
[ti] Forwarding ports...
[ti] -- 22 =&gt; 2203 (adapter 1)
[ti] Running 'pre-boot' VM customizations...
[ti] Booting VM...
[ti] Waiting for machine to boot. This may take a few minutes...
[ti] Machine booted and ready!
[ti] Setting hostname...
[ti] Configuring and enabling network interfaces...
[ti] Mounting shared folders...
[ti] -- /vagrant
[ti] VM already provisioned. Run `vagrant provision` or use `--provision` to force it
</code></pre></div></div> <p>다음은 default로 설정되어 있는 CRS서버에 ssh로 연결한 모습이다. 게스트 운영체에제서 /vagrant로 이동하면 자동으로 Vagrant 스크립트에 의해 호스트 운영체제의 현재 디렉토리를 공유하고 있음을 알 수 있다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Repos/cgc $ vagrant ssh
Linux crs 3.13.11-ckt32-cgc #1 SMP Tue Jul 12 14:51:24 UTC 2016 i686

The programs included with the Debian GNU/Linux system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.

Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent
permitted by applicable law.
Last login: Fri Jul 29 05:31:37 2016 from 10.0.2.2
vagrant@crs:~$ cd /vagrant/
vagrant@crs:/vagrant$ ls
Vagrantfile  peda  samples  vm.json
</code></pre></div></div> <p><strong>3. Challenge Binaries and Utilities</strong></p> <p>2015년 Grand Challenge에서 DARPA는 대회용으로 131개의 Compile된 Binary만을 공개했다. 하지만, 현재 Github Repository에서 모든 바이너리의 소스코드와 취약점, PoV (Proof of Vulnerability), 그리고 상세한 설명 (Service Description)을 제공하고 있다. </p> <p>131개의 바이너리는 단순하게 만든 운영체제에서 실제 서비스와 유사할 만큼의 복잡도를 가진 서비스를 제공할 수 있다. 72개의 CC 파일 (7000 LOC), 1236개의 헤더 (19만 LOC), 1996개의 C 파일 (20만 LOC), 6000여 개의 함수와 590개의 PoV가 이를 대변한다. </p> <p>(1) CGC Executable Format (CGCEF)</p> <p>CGC 실행 포맷은 처음 15바이트의 헤더가 ELF와 다르다. \x7fCGC로 시작함을 알 수 있다. </p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define CI_NIDENT  16
typedef struct{
    unsigned char  e_ident[EI_NIDENT];
#define C_IDENT "\x7fCGC\x01\x01\x01\x43\x01\x00\x00\x00\x00\x00\x00"
    /* ELF vs CGC identification
    * ELF          CGC
    *  0x7f        0x7f
    *  'E'        'C'
    *  'L'        'G'
    *  'F'        'C'
    *  class      1      : '1' translates to 32bit ELF
    *  data        1      : '1' translates to little endian ELF
    *  version    1      : '1' translates to little endian ELF
    *  osabi      \x43    : '1' CGC
    *  abiversion  1      : '1' translates to version 1
    *  padding    random values
    */
    uint16_t    e_type;        /* Must be 2 for executable */
    uint16_t    e_machine;      /* Must be 3 for i386 */
    uint32_t    e_version;      /* Must be 1 */
    uint32_t    e_entry;        /* Virtual address entry point */
    uint32_t    e_phoff;        /* Program Header offset */
    uint32_t    e_shoff;        /* Section Header offset */
    uint32_t    e_flags;        /* Must be 0 */
    uint16_t    e_ehsize;      /* CGC header's size */
    uint16_t    e_phentsize;    /* Program header entry size */
    uint16_t    e_phnum;        /* # program header entries */
    uint16_t    e_shentsize;    /* Section header entry size */
    uint16_t    e_shnum;        /* # section header entries */
    uint16_t    e_shstrndx;    /* sect header # of str table */
} CGC32_hdr;
</code></pre></div></div> <p>CGC 실행포맷은 cgcef-verify라는 도구로 정상여부를 확인할 수 있으며, readelf와 같이 readcgcef로 읽을 수 있다.  PATH 환경변수를 살짝 조정해서 기존의 bintools을 편하게 대체할 수도 있다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vagrant@crs:/vagrant$ cgcef_verify ./samples/cqe-challenges/CROMU_00001/bin/CROMU_00001
vagrant@crs:/vagrant$ readcgcef -e ./samples/cqe-challenges/CROMU_00001/bin/CROMU_00001
CGCEF Header:
  Magic:   7f 43 47 43 01 01 01 43 01 4d 65 72 69 6e 6f 00 
  Class:                             CGCEF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            CGC
  ABI Version:                       1
  Type:                              EXEC (Executable file)
  Machine:                           Intel i386
  Version:                           0x1
  Entry point address:               0x804a789
  Start of program headers:          52 (bytes into file)
  Start of section headers:          94208 (bytes into file)
  Flags:                             0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         3
  Size of section headers:           40 (bytes)
  Number of section headers:         6
  Section header string table index: 5

CGCEf file type is EXEC (Executable file)
Entry point 0x804a789
There are 3 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00060 0x00060 R   0x4
  LOAD           0x000000 0x08048000 0x08048000 0x02da0 0x02da0 R E 0x1000
  LOAD           0x002da0 0x0804bda0 0x0804bda0 0x14217 0x14217 RW  0x1000

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .text .rodata 
   02     .data 
There are 6 section headers, starting at offset 0x17000:

Section Headers:
  [Nr] Name           Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0] (null)         NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text          PROGBITS        080480a0 0000a0 002a03 00  AX  0   0 16
  [ 2] .rodata        PROGBITS        0804aab0 002ab0 0002f0 00   A  0   0 16
  [ 3] .data          PROGBITS        0804bda0 002da0 014217 00  WA  0   0  4
  [ 4] .comment       PROGBITS        00000000 016fb7 00001e 01  MS  0   0  1
  [ 5] .shstrtab      STRTAB          00000000 016fd5 000028 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

vagrant@crs:/vagrant$ ls /usr/i386-linux-cgc/bin
ar            clang-check   lli               llvm-cov        llvm-mc        llvm-rtdyld      nm
as            clang-format  lli-child-target  llvm-diff       llvm-mcmarkup  llvm-size        objcopy
bugpoint      clang-tblgen  llvm-ar           llvm-dis        llvm-nm        llvm-stress      objdump
c-index-test  ld            llvm-as           llvm-dwarfdump  llvm-objdump   llvm-symbolizer  opt
clang         ld.bfd        llvm-bcanalyzer   llvm-extract    llvm-ranlib    llvm-tblgen      ranlib
clang++       llc           llvm-config       llvm-link       llvm-readobj   macho-dump       strip

vagrant@crs:/vagrant$ export PATH=/usr/i386-linux-cgc/bin:$PATH
vagrant@crs:/vagrant$ which objdump
/usr/i386-linux-cgc/bin/objdump

./samples/cqe-challenges/CROMU_00001/bin/CROMU_00001: file format cgc32-i386
architecture: i386, flags 0x00000102:
EXEC_P, D_PAGED
start address 0x0804a789
</code></pre></div></div> <p>(2) CGCEF Program Headers</p> <p>CGCEF는 섹션유형이(section type) 4개밖에 없다. 모든 바이너리는 정적으로 연결(Statically Linked)되어 있으며, 동적링킹 (Dynamic Linked)과 thread를 사용하지 않는다. 따라서 TLS (Thread Local Storage) 섹션도 존재하지 않는다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct{
    uint32_t        p_type;        /* Section type */
#define PT_NULL    0              /* Unused header */
#define PT_LOAD    1              /* Segment loaded into mem */
#define PT_PHDR    6              /* Program hdr tbl itself */
#define PT_CGCPOV2  0x6ccccccc      /* CFE Type 2 PoV flag sect */
    uint32_t        p_offset;      /* Offset into the file */
    uint32_t        p_vaddr;        /* Virtual program address */
    uint32_t        p_paddr;        /* Set to zero */
    uint32_t        p_filesz;      /* Section bytes in file */
    uint32_t        p_memsz;        /* Section bytes in memory */
    uint32_t        p_flags;        /* section flags */
#define PF_X        (1&lt;&lt;0)          /* Mapped executable */
#define PF_W        (1&lt;&lt;1)          /* Mapped writable */
#define PF_R        (1&lt;&lt;2)          /* Mapped readable */
    /* Acceptable flag combinations are:
    *        PF_R
    *        PF_R|PF_W
    *        PF_R|PF_X
    *        PF_R|PF_W|PF_X
    */
    uint32_t        p_align;        /* Only used by core dumps */
} CGC32_Phdr;

vagrant@crs:/vagrant$ objdump -h ./samples/cqe-challenges/CROMU_00001/bin/CROMU_00001

./samples/cqe-challenges/CROMU_00001/bin/CROMU_00001: file format cgc32-i386

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002a03  080480a0  080480a0  000000a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .rodata       000002f0  0804aab0  0804aab0  00002ab0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         00014217  0804bda0  0804bda0  00002da0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .comment      0000001e  00000000  00000000  00016fb7  2**0
                  CONTENTS, READONLY
</code></pre></div></div> <p>(3) CGCEF Section Headers</p> <p>섹션헤더는 디버깅할 때 정보 제공용으로만 사용하며, Loader는 이 섹션을 무시하고 로딩한다. 배포용(release)으로 제공하는 바이너리는 보통 이 섹션이 제거되고(stripped) 없다고 보면 된다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct {
    uint32_t        sh_name;        /* Name (index into strtab) */
    uint32_t        sh_type;        /* Section type */
#define SHT_SYMTAB  2              /* Symbol table */
#define SHT_STRTAB  3              /* String Table */
    uint32_t        sh_flags;
#define SHT_WRITE  (1&lt;&lt;0)          /* Section is writable */
#define SHT_ALLOC  (1&lt;&lt;1)          /* Section is in memory */
#define SHT_EXECINSTR (1&lt;&lt;2)        /* Section contains code */
    uint32_t        sh_addr;        /* Address of section */
    uint32_t        sh_offset;      /* Offset into file */
    uint32_t        sh_size;        /* Section size in file */
    uint32_t        sh_link;
            /* When sh_type is SHT_SYMTAB, sh_link is the index of
            * the associated SHT_STRTAB section
            */
    uint32_t        sh_info;
            /* When sh_type is SHT_SYMTAB, info is one greater
            * than the symbol table index of the last local
            * symbol.
            */
    uint32_t        sh_addralign;  /* Alignment constraints */
    uint32_t        sh_entsize;
            /* Size in bytes of each entry pointed to by this
            * section table */
} CGC32_Shdr;
</code></pre></div></div> <p>(4) IDA Pro modules for CGC</p> <p>Reversing을 할 때 표준도구처럼 많은 사람들이 애용하는 IDA Pro에서도 Loading할 수 있도 Module을 제공한다. <a href="http://idabook.com/cgc/">여기</a>서 (<a href="http://idabook.com/cgc/">http://idabook.com/cgc/</a>) 버전에 맞는 모듈을 다운받아 설치하면 CGC 바이너리를 로딩할 때 자동으로 Loader를 선택해 준다.</p> <p>(5) How to run CGC binary as a service</p> <p>일일히 실행하기 번거로우면, 다음과 같이 임의로 서버와 클라이언트를 실행해 확인해 볼 수 있다. 다음과 같이 cqe 바이너리의 poller directory 내에 for-testing과 for-release 두 가지 형태의 많은 sample data로 테스트해 볼 수 있다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># SEVER SIDE
vagrant@crs:/vagrant/cqe-challenges/KPRCA_00022/build/release/bin$ cb-server --insecure -p 10000 -d /vagrant/cqe-challenges/CROMU_00015/bin /vagrant/cqe-challenges/CROMU_00015/bin/CROMU_00015
connection from: 127.0.0.1:4499
negotiation flag: 0
getting random seed
seed: 22733022E8A0D77BB3F089EA9A2DD56593E0373B739737F976F4EFC937BEB1A4FFEAF08F62D708E22C928970F728052F
stat: /vagrant/cqe-challenges/CROMU_00015/bin/CROMU_00015 filesize 159244
CB exited (pid: 7672, exit code: 0)
total children: 1
total maxrss 96
total minflt 68
total utime 0.000000
total sw-cpu-clock 13506359
total sw-task-clock 13504409
CB exited (pid: 7671, exit code: 0)

# CLIENT SIDE
vagrant@crs:/vagrant/cqe-challenges/CROMU_00015$ cb-replay --host 127.0.0.1 --port 10000 ./poller/for-testing/POLL_00800.xml 
# CROMU_00015 - ./poller/for-testing/POLL_00800.xml
# connected to ('127.0.0.1', 10000)
ok 1 - match: string
ok 2 - write: sent 2 bytes
ok 3 - match: string
ok 4 - write: sent 11 bytes
ok 5 - match: string
ok 6 - write: sent 2 bytes
ok 7 - match: string
ok 8 - match: string
ok 9 - write: sent 2 bytes
ok 10 - match: string
ok 11 - match: string
ok 12 - write: sent 2 bytes
ok 13 - match: string
ok 14 - write: sent 2 bytes
ok 15 - match: string
ok 16 - write: sent 3 bytes
ok 17 - match: string
ok 18 - write: sent 5 bytes
ok 19 - match: string
ok 20 - write: sent 2 bytes
ok 21 - match: string
ok 22 - write: sent 8 bytes
ok 23 - match: string
ok 24 - write: sent 2 bytes
ok 25 - match: string
ok 26 - write: sent 8 bytes
ok 27 - match: string
ok 28 - write: sent 2 bytes
ok 29 - match: string
ok 30 - write: sent 9 bytes
ok 31 - match: string
ok 32 - write: sent 3 bytes
ok 33 - match: string
ok 34 - write: sent 6 bytes
ok 35 - match: string
ok 36 - write: sent 2 bytes
ok 37 - match: string
ok 38 - write: sent 8 bytes
ok 39 - match: string
ok 40 - write: sent 3 bytes
ok 41 - match: string
ok 42 - write: sent 9 bytes
ok 43 - match: string
ok 44 - write: sent 2 bytes
ok 45 - match: string
ok 46 - write: sent 8 bytes
ok 47 - match: string
ok 48 - write: sent 2 bytes
ok 49 - match: string
ok 50 - write: sent 8 bytes
ok 51 - match: string
ok 52 - write: sent 2 bytes
ok 53 - match: string
ok 54 - match: string
ok 55 - write: sent 2 bytes
ok 56 - match: string
ok 57 - write: sent 9 bytes
ok 58 - match: string
ok 59 - write: sent 2 bytes
ok 60 - match: string
ok 61 - write: sent 9 bytes
ok 62 - match: string
ok 63 - write: sent 2 bytes
ok 64 - match: string
ok 65 - write: sent 8 bytes
ok 66 - match: string
ok 67 - write: sent 2 bytes
ok 68 - match: string
ok 69 - write: sent 8 bytes
ok 70 - match: string
ok 71 - write: sent 3 bytes
ok 72 - match: string
ok 73 - write: sent 2 bytes
ok 74 - match: string
ok 75 - write: sent 452 bytes
ok 76 - match: string
ok 77 - write: sent 2 bytes
ok 78 - match: string
ok 79 - match: string
ok 80 - write: sent 2 bytes
ok 81 - match: string
ok 82 - write: sent 2 bytes
ok 83 - match: string
ok 84 - write: sent 2 bytes
ok 85 - match: string
ok 86 - write: sent 8 bytes
ok 87 - match: string
ok 88 - write: sent 2 bytes
ok 89 - match: string
ok 90 - write: sent 8 bytes
ok 91 - match: string
ok 92 - write: sent 3 bytes
ok 93 - match: string
ok 94 - write: sent 8 bytes
ok 95 - match: string
ok 96 - write: sent 2 bytes
ok 97 - match: string
ok 98 - write: sent 8 bytes
ok 99 - match: string
ok 100 - write: sent 2 bytes
ok 101 - match: string
ok 102 - write: sent 8 bytes
ok 103 - match: string
ok 104 - write: sent 3 bytes
ok 105 - match: string
ok 106 - write: sent 5 bytes
ok 107 - match: string
ok 108 - write: sent 2 bytes
ok 109 - match: string
ok 110 - write: sent 8 bytes
ok 111 - match: string
ok 112 - write: sent 2 bytes
ok 113 - match: string
ok 114 - write: sent 8 bytes
ok 115 - match: string
ok 116 - write: sent 2 bytes
ok 117 - match: string
ok 118 - write: sent 8 bytes
ok 119 - match: string
ok 120 - write: sent 2 bytes
ok 121 - match: string
ok 122 - write: sent 8 bytes
ok 123 - match: string
ok 124 - write: sent 2 bytes
ok 125 - match: string
ok 126 - write: sent 8 bytes
ok 127 - match: string
ok 128 - write: sent 3 bytes
ok 129 - match: string
ok 130 - write: sent 12 bytes
ok 131 - match: string
ok 132 - write: sent 3 bytes
ok 133 - match: string
ok 134 - write: sent 2 bytes
ok 135 - match: string
ok 136 - write: sent 13 bytes
ok 137 - match: string
ok 138 - write: sent 2 bytes
ok 139 - match: string
# tests passed: 139
# tests failed: 0
# total tests passed: 139
# total tests failed: 0
# polls passed: 1
# polls failed: 0
</code></pre></div></div> <p>또한 pov 디렉토리에는 실제 취약점을 trigger하는 입력값(input)을 가지고 있어 실제 취약한 코드가 어디인지 살펴보기에 안성맞춤이다. 아래 예제는 client와 통신한 후 exit code가 0이 아닌 상태로 종결되었기에 서버 측에서 실제 register status를 보여주고 있다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># SERVER SIDE
vagrant@crs:/vagrant/cqe-challenges/KPRCA_00022/build/release/bin$ cb-server --insecure -p 10000 -d /vagrant/cqe-challenges/CROMU_00015/bin /vagrant/cqe-challenges/CROMU_00015/bin/CROMU_00015
connection from: 127.0.0.1:38142
negotiation flag: 0
getting random seed
seed: 9D7F1CABD61E527C629EEB20FD4A6E75D01A326A24CA2572DB294255EF554755FC498388FCAB7BCDFBAD3AB1B07BB0B6
stat: /vagrant/cqe-challenges/CROMU_00015/bin/CROMU_00015 filesize 159244
register states - eax: 0805a000 ecx: 00000000 edx: b7ffe000 ebx: 00000000 esp: baaaad18 ebp: baaaad24 esi: baaaaef0 edi: 00000000 eip: 08058e27
CB generated signal (pid: 7686, signal: 11)
total children: 1
total maxrss 68
total minflt 20
total utime 0.000000
total sw-cpu-clock 1076908
total sw-task-clock 1208191

# CLIENT SIDE
vagrant@crs:/vagrant/cqe-challenges/CROMU_00015$ cb-replay --host 127.0.0.1 --port 10000 ./pov/POV_00006.xml  
# service - ./pov/POV_00006.xml
# connected to ('127.0.0.1', 10000)
ok 1 - read length
ok 2 - write: sent 2 bytes
ok 3 - read length
ok 4 - write: sent 29 bytes
ok 5 - slept 1.000000
# tests passed: 5
# tests failed: 0
# total tests passed: 5
# total tests failed: 0
# polls passed: 1
# polls failed: 0
</code></pre></div></div> <p><strong>4. CWE Distribution for CGC Binaries</strong></p> <p>CWE는 <a href="https://cwe.mitre.org/">MITRE (https://cwe.mitre.org/)</a>에서 제공하는 일종의 취약점 분류(Common Weakness Enumeration)라고 볼 수 있다.  Semi-Final에서 제공한 131개의 바이너리 Description을 기반으로 살펴본 결과 다음 표와 같이 대략 60여개의 분류와 300개 이상의 취약점을 가지고 있음을 알 수 있다.</p> <p><a href="http://dandylife.net/blog/archives/634/cgc">[table id=2 /]</a></p> <p>TOP 5는 짐작할 수 있듯이 Classic Buffer Overflow, Stack-based Overflow, Heap-based Overflow, Out-of-Bounds Write, Null Pointer Dereferencing이다.</p> <p><a href="http://dandylife.net/blog/archives/634/cgc"><br/> <img src="http://dandylife.net/blog/wp-content/uploads/2016/07/cgc.png" alt="cgc"/></a></p>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Attack &amp;amp; Defense, Cyber Warfare"/><category term="cgc"/><category term="cyber grand challenge"/><category term="darpa"/><category term="event"/><summary type="html"><![CDATA[1. Overview]]></summary></entry><entry><title type="html">Juggling the Gadgets: Instruction Displacement to Mitigate Code Reuse Attack</title><link href="https://kevinkoo001.github.io/blog/2016/juggling-the-gadgets-instruction-displacement-to-mitigate-code-reuse-attack/" rel="alternate" type="text/html" title="Juggling the Gadgets: Instruction Displacement to Mitigate Code Reuse Attack"/><published>2016-05-31T05:58:56+00:00</published><updated>2016-05-31T05:58:56+00:00</updated><id>https://kevinkoo001.github.io/blog/2016/juggling-the-gadgets-instruction-displacement-to-mitigate-code-reuse-attack</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2016/juggling-the-gadgets-instruction-displacement-to-mitigate-code-reuse-attack/"><![CDATA[<p><strong>I. Background</strong></p> <p>As modern OS has banned running arbitrary <strong>code by injection</strong> (i.e., a page in a virtual memory space cannot be set both executable and writable permission at the same time by default), <strong>code reuse</strong> attack has gained its popularity by taking advantage of the existing permission such as [return/jump/call]-oriented programming. (i.e., ROP attack)</p> <p>The essence of the attack is that an adversary has the power of <strong>predicting address space</strong> and <strong>diverting control flow.</strong> Hence, two main approaches to defend against code reuse are either to break the knowledge of code layout with <strong>randomization</strong> or to restrict the use of the branches with <strong>control flow integrity</strong>.</p> <p><strong>II. Overview of Instruction Displacement and Gadgets</strong></p> <p>This work focuses on the former perspective, code diversification in particular. <a href="http://dandylife.net/blog/archives/477">One of previous works </a>introduces an In-Place Randomization (IPR) including instruction substitution, instruction reordering and/or register reassignment. The advantage of IPR is that it could be applied to stripped binaries thus practical for real applications with (theoretically) no overhead. It assumed both incomplete control flow graph and inaccurate disassembly from a binary that has been stripped off additional information - debugging symbols and source code - during compilation. However, it ended up with remaining gadgets (20%) that might be enough for the construction of a functional ROP payload.</p> <p>The idea is to break more gadgets by <strong>instruction displacement</strong>. The goal of this technique is to maximize the gadget coverage. It might be thought of another way on top of IPR. However, displacement does not necessarily combine with it. Instruction displacement can be tied to any diversification technique with incomplete gadget coverage in order to increase it.</p> <p>The following figure illustrates an example of what gadgets look like. (Here they are defined by looking ahead up to 5 instructions long from a ‘<em>ret</em>’ instruction for the purpose of comparison with previous work.) </p> <p><a href="http://dandylife.net/blog/archives/606/intended_vs_unintended"><img src="http://dandylife.net/blog/wp-content/uploads/2016/05/intended_vs_unintended.png" alt="intended_vs_unintended"/></a></p> <p>The dotted box represents pre-discovered gadgets. Assume that the process of gadget discovery is known thus we have the same power of obtaining gadgets with an adversary. The bold letters mean the first byte of each instruction. There are six different gadgets varying from 2 to 10 bytes in size. G1, G5, and G6 are <strong>intended gadgets</strong> because the starting byte of the first instruction is the same with the intended instructions; whereas, G2, G3, and G4 are <strong>unintended gadgets</strong> because the starting byte of the first instruction is different from the intended instructions. This shows that a lot of gadgets are <strong>nested</strong> in nature.</p> <p><strong>III. High Level View</strong></p> <p>A high level view of gadget displacement can be seen as following.</p> <p><a href="http://dandylife.net/blog/archives/606/high_view"><img src="http://dandylife.net/blog/wp-content/uploads/2016/05/high_view.png" alt="high_view"/></a></p> <p>First, we obtain pre-computed gadgets and displace them to a new section, named .<em>ropf</em>. (which has meant _rop-proof _area) Note that the unit of displacement should be within a basic block to maintain the semantic of the original program, which is the most important requirement.</p> <p>In order to displace gadgets, intuitively a <em>jmp</em> instruction is required that takes 5 bytes space; 1 byte for mnemonic and 4 bytes for a relative address. In other words, 5-byte-space in a single basic block is necessary for displacement. The remaining area is filled with <em>0xCC</em> or INT 3 (interrupt 3). The INT <strong>3</strong> instruction is used by debuggers to temporarily replace an instruction to set a break point. Therefore any attempt to access to it would interrupt a program.</p> <p>Another consideration is when the displaced area contains any branches and calls with relative addresses. All code references should be re-computed properly. Likewise, when the displaced area includes any absolute address in a relocation table (i.e., .<em>reloc</em> section in a PE file), it has to be updated accordingly as well.</p> <p><strong>IV. Displacement Strategy</strong></p> <p>To achieve both efficiency and effectiveness for binary instrumentation, we set up the strategy like followings:</p> <ul> <li>First, in general, jumping back and forth between two sections (.<em>text</em> and .<em>ropf</em>) is required. However, it is not necessary if the displaced region ends with either unconditional jump or return instruction because they know where to go back. For example, a <em>ret</em> instruction would take whatever value on the stack to return.</li> <li>It would be better to keep the number of displaced regions low for performance degradation. This can be resolved by choosing the largest gadget to include all nested gadgets within a basic block. It helps to break the gadgets whose sizes are less than 5 bytes.</li> <li>For intended gadgets, it is simple enough to find the starting byte of the first intended instruction of the gadget and displace it into a .<em>ropf</em>.</li> <li>For unintended gadgets, find the instruction all the way back in the same basic block for displacement. Otherwise, an attacker could also follow the inserted jump to make use of the existing gadgets.  </li> <li>Finally, we shuffle the displaced instructions around in a .<em>ropf</em> to avoid generating the same binary.</li> </ul> <p>Putting all things together, the following algorithm summarizes the above. Per each gadget, it decides whether or not the gadget can be broken when IPR is not available.</p> <p><a href="http://dandylife.net/blog/archives/606/disp_algo"><img src="http://dandylife.net/blog/wp-content/uploads/2016/05/disp_algo.png" alt="disp_algo"/></a></p> <p><strong>V. Binary Instrumentation</strong></p> <p>In this work, PE (portable executable),  a standard format in Windows, has been targeted in x86 machine. (You may find <a href="http://dandylife.net/blog/archives/388">here</a> useful for more about PE) Briefly, PE consists of several section headers and corresponding data.</p> <p><a href="http://dandylife.net/blog/archives/606/binary"><img src="http://dandylife.net/blog/wp-content/uploads/2016/05/binary.png" alt="binary"/></a></p> <p>Above all, a new .ropf section header is appended at the end of existing section headers and a .ropf section that displaced code snippets reside in at the end of the binary. Next, all relocation entries are rebuilt in a relocation section. And some optional header fields including size of code and checksum should be adjusted accordingly. Other than those, all other area has to be preserved as they are. Displacing other sections may increase a complexity a lot during binary instrumentation.</p> <p><a href="http://dandylife.net/blog/archives/606/reloc_table"><img src="http://dandylife.net/blog/wp-content/uploads/2016/05/reloc_table.png" alt="reloc_table"/></a></p> <p>For a relocation table, it should be entirely reconstructed rather than appending new entries. This is because if original entries would be left, the inserted jump instruction can be overwritten during loading a binary into memory. A relocation table in a PE file consists of multiple relocation blocks. Each block starts with relative virtual address (RVA), block size and a series of entries of 2-byte value each. The first 4 bits represent type, and the last 12 bits represent offset.</p> <p>For the example of the entry 0x304C in the figure above, 0x3000 means a relocation entry type and 0x4C is an offset from a RVA of the block, which means the absolute address in a virtual address 0x1C04C has to updated appropriately when loaded. Note that total number of all entries should be identical at all times.</p> <p><strong>VI. Evaluation</strong></p> <p>From almost 2,700 samples from Windows 7, 8.1 and benign applications, more than 13 million gadgets has been found in total. 6.37% gadgets are located in the unreachable regions (in reds below) mostly because of the failure of drawing control flow graph. The following plot illustrates an interesting the distribution of gadget kinds (small ones, unintended ones, and call-preceded ones) and that of broken gadgets. </p> <p><a href="http://dandylife.net/blog/archives/606/result"><img src="http://dandylife.net/blog/wp-content/uploads/2016/05/result.png" alt="result"/></a></p> <p>The next Venn diagram shows how two different techniques are <strong>complementary</strong> at a glance. The figures in parenthesis are the ones except unreachable gadgets. Total coverage with IPR only was about 85% whereas it was about 90% with displacement only. Using both, it goes up to 97%. The unbroken gadgets ends up with 2.6%.</p> <p><a href="http://dandylife.net/blog/archives/606/venn"><img src="http://dandylife.net/blog/wp-content/uploads/2016/05/venn.png" alt="venn"/></a></p> <p>For the overhead tests, the industry standard _SPEC2006 _has been used. The performance overhead was around 0.36% on average. Having been some negative overheads, we performed statistical t-test done by establishing the null hypothesis that the means of CPU runtime overhead between original binaries and instrumented ones are the same. The result was that it rejects to fail the null hypothesis. In other words, there is no statically significant difference for negative overheads with 95% confidence interval.</p> <p><strong>VII. Discussion and Limitation</strong></p> <p>First of all, the number of displaceable gadgets still depends on the coverage of disassembly and CFG extraction. In addition, displacement technique requires at least 5 byte space to insert <em>jmp</em> instruction.</p> <p>Next, it cannot defend against <em>ret2libc</em> and <em>JIT-ROP.</em>  However, for return-to-libc, the real attack with actual APIs often requires code reuse for setting up parameters. The latest research shows the idea of JIT-ROP defense by making pages just executable only without readable. Since it constructs the gadgets on the fly after information leak, therefore, displacement technique can be leveraged to prevent JIT-ROP for fine-grained randomization.</p> <p>Lastly, it cannot break the entry-point gadgets, which was less than 1%. </p> <p><strong>VIII. Final words</strong></p> <p>You may find <a href="http://dandylife.net/blog/wp-content/uploads/2016/05/displacement.asiaccs16.pdf">the paper </a> and <a href="http://dandylife.net/blog/wp-content/uploads/2016/05/Juggling-the-Gadgets.pdf">the slide</a> useful in details, which presented in ACM Asia Conference on Computer and Communications Security 2016 (<a href="http://meeting.xidian.edu.cn/conference/AsiaCCS2016/program.html">ASIACCS 2016</a>). The experimental code is now publicly available at <a href="https://github.com/kevinkoo001/ropf">this repository</a> at my Github. </p>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Attack &amp;amp; Defense, Cyber Warfare"/><category term="gadget"/><category term="return oriented programming"/><category term="rop"/><summary type="html"><![CDATA[I. Background]]></summary></entry><entry><title type="html">Assembly visualizer for reversing</title><link href="https://kevinkoo001.github.io/blog/2016/reverse-engineering-resources/" rel="alternate" type="text/html" title="Assembly visualizer for reversing"/><published>2016-01-21T22:22:19+00:00</published><updated>2016-01-21T22:22:19+00:00</updated><id>https://kevinkoo001.github.io/blog/2016/reverse-engineering-resources</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2016/reverse-engineering-resources/"><![CDATA[<p><a href="http://dandylife.net/blog/archives/565/reverseengineerbook"><img src="http://dandylife.net/blog/wp-content/uploads/2016/01/ReverseEngineerBook.png" alt="ReverseEngineerBook"/></a></p> <p><a href="http://yurichev.com/">Dennis Yurichev</a> released an excellent reversing book for free, “<a href="http://beginners.re/">Reverse Engineering for Beginners</a>”. This allows readers who eager to learn reversing to do so systematically without worrying about affordability. The book is available in both English and Russian version, and full and (lite) introductory version. If you are looking for Korean version, it is also available thanks to 민병호 (translator) and Acorn Press - “<a href="http://www.acornpub.co.kr/book/reversing-for-beginners">실전 연습으로 완성하는 리버싱</a>”. All challenges/exercises/problems/tasks are accessible <a href="http://challenges.re/">here</a>.</p> <p>With a lot of fruitful exercises, I found it very useful with the tool, <em><a href="https://github.com/ynh/cpp-to-assembly">C/C++ to assembly visualizer</a></em>. Literally, it visualizes the relationship between C/C++ and assembly code via an awesome HTML web interface. It takes advantage of <a href="https://nodejs.org">Node.js</a>.</p> <p>Here is a simple step to install the interface.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ sudo apt-get install npm
... (omitted) ...

$ npm install -d
... (omitted) ...
cluster@0.7.7 node_modules/cluster
├── log@1.4.0
└── mkdirp@0.5.1 (minimist@0.0.8)

express@3.0.0-rc4 node_modules/express
├── methods@0.0.1
├── fresh@0.1.0
├── range-parser@0.0.4
├── cookie@0.0.4
├── crc@0.2.0
├── commander@0.6.1
├── mkdirp@0.3.3
├── debug@2.2.0 (ms@0.7.1)
├── send@0.0.4 (mime@1.2.6)
└── connect@2.4.4 (pause@0.0.1, bytes@0.1.0, qs@0.4.2, formidable@1.0.11)

stylus@0.53.0 node_modules/stylus
├── css-parse@1.7.0
├── debug@2.2.0 (ms@0.7.1)
├── mkdirp@0.5.1 (minimist@0.0.8)
├── source-map@0.1.43 (amdefine@1.0.0)
├── glob@3.2.11 (inherits@2.0.1, minimatch@0.3.0)
└── sax@0.5.8

forever@0.15.1 node_modules/forever
├── path-is-absolute@1.0.0
├── object-assign@3.0.0
├── colors@0.6.2
├── clone@1.0.2
├── timespan@2.3.0
├── nssocket@0.5.3 (eventemitter2@0.4.14, lazy@1.0.11)
├── optimist@0.6.1 (wordwrap@0.0.3, minimist@0.0.10)
├── cliff@0.1.10 (eyes@0.1.8, colors@1.0.3)
├── winston@0.8.3 (cycle@1.0.3, stack-trace@0.0.9, eyes@0.1.8, isstream@0.1.2, async@0.2.10, pkginfo        @0.3.1)
├── shush@1.0.0 (strip-json-comments@0.1.3, caller@0.0.1)
├── utile@0.2.1 (deep-equal@1.0.1, ncp@0.4.2, async@0.2.10, i@0.3.4, mkdirp@0.5.1, rimraf@2.5.0)
├── prettyjson@1.1.3 (colors@1.1.2, minimist@1.2.0)
├── nconf@0.6.9 (ini@1.3.4, async@0.2.9, optimist@0.6.0)
├── forever-monitor@1.6.0 (minimatch@2.0.10, ps-tree@0.0.3, broadway@0.3.6, chokidar@1.4.2)
└── flatiron@0.4.3 (optimist@0.6.0, director@1.2.7, prompt@0.2.14, broadway@0.3.6)
npm info ok
</code></pre></div></div> <p>If you have an error while starting <em>npm</em> due to node stuff, creating symbolic might help. Once you start your own web server, check out the port 8080 open as following. </p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ln -s /usr/bin/nodejs /usr/bin/node
$ sudo npm install coffee-script

$ npm start
&gt; Assembly@0.0.1 start /root/gits/cpp-to-assembly
&gt; forever start -c coffee app.coffee
warn:    --minUptime not set. Defaulting to: 1000ms
warn:    --spinSleepTime not set. Your script will exit if it does not stay up for at least 1000ms
info:    Forever processing file: app.coffee

$ netstat -anlpt
Active Internet connections (servers and established)
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      27629/nodeNow you can enjoy&amp;nbsp;a nice illustration to map your code to assembly. You might want to use&amp;nbsp;&lt;a href="https://assembly.ynh.io/" target="_blank" data-mce-href="https://assembly.ynh.io/"&gt;the demo&lt;/a&gt; as well.
</code></pre></div></div> <p>Now you can enjoy a beautiful illustration to map your code to assembly, by pasting your own code. You may want to check out the <a href="https://assembly.ynh.io/">demo</a> in advance. The following example shows how the function <em>snprintf()</em> is converted into machine-level code in a 64-bit machine.</p> <p><a href="http://dandylife.net/blog/archives/565/code_comparison"><img src="http://dandylife.net/blog/wp-content/uploads/2016/01/code_comparison.png" alt="code_comparison"/></a></p>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Miscellaneous Stuff"/><category term="assembly visualizer"/><category term="Reversing"/><summary type="html"><![CDATA[]]></summary></entry><entry><title type="html">Code Reuse Attacks and Defenses</title><link href="https://kevinkoo001.github.io/blog/2016/code-reuse-attacks-and-defenses/" rel="alternate" type="text/html" title="Code Reuse Attacks and Defenses"/><published>2016-01-16T19:52:51+00:00</published><updated>2016-01-16T19:52:51+00:00</updated><id>https://kevinkoo001.github.io/blog/2016/code-reuse-attacks-and-defenses</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2016/code-reuse-attacks-and-defenses/"><![CDATA[<h3 id="1-introduction"><strong>1. Introduction</strong></h3> <p>Writing bug-free codes is quite challenging - almost infeasible - due to its high complexity and the limitation of extensive testing for both functionality and performance. In particular, memory corruption bugs have provided adversaries with a stepping stone that can lead to successful attacks. Although modern programming languages are designed to be safe against memory corruption vulnerabilities, many applications and systems still use the C and C++ programming languages, which support low level features.</p> <p>During the last thirty years, various defense mechanisms have been proposed and deployed in order to eradicate code injection attacks, such as buffer overruns. Along with them, the offense side responds against existing enforcement mechanisms by introducing new evasion techniques. Despite the fact that memory corruption has been recognized as a well-known issue over several decades, many buggy programs still suffer from this classic vulnerability, ranked third <a href="https://www.sans.org/top25-software-errors/">according to MITRE</a>. Memory corruption has been studied for quite a long time as a research topic, but the problem of achieving a trade-off between effectiveness and efficiency (or between security and performance) remains open. After both DEP and ASLR have been deployed in modern operating systems by default, a large portion of attacks employ the code reuse technique and its variants to bypass existing defense mechanisms. The arms race between code reuse attacks and defenses is still an ongoing operation.</p> <p> </p> <h3 id="2-brief-history"><strong>2. Brief History</strong></h3> <p>Historically, the Morris worm of 1988 was recorded as the first instance of a code injection attack that had impact on real servers, propagating through the Internet. Taking advantage of a buffer overflow vulnerability, it could crash running systems on purpose. Attacks using memory corruption started to become a mainstream threat after the disclosure of their operation by Aleph One in 1996. Another notorious attack was the Code Red worm, which infected 250,000 machines during 9 hours all over the world against Microsoft IIS Servers in 2001. Two years later, SQL Slammer slowed down the Internet by infecting 75,000 machines within merely 10 minutes. These worms all relied on the exploitation of buffer overrun vulnerabilities. <em>(<a href="https://www.caida.org/publications/papers/2002/codered/codered.pdf">Code-Red: a case study on the spread and victims of an Internet</a></em><br/> <a href="https://www.caida.org/publications/papers/2002/codered/codered.pdf"><em>worm</em> by D.Moore et al.</a>)</p> <p><a href="http://dandylife.net/blog/archives/551/divert_control_flow-2"><img src="http://dandylife.net/blog/wp-content/uploads/2016/01/divert_control_flow-e1452969001684.png" alt=""/></a></p> <p>Traditional memory corruption exploits can be achieved by pointing to the injected code on the stack or heap which data resides in, followed by executing them. Based upon this observation in the past, the primary goal is to execute the arbitrarily injected code by erroneously dereferencing a pointer for control over a target to exploit (<a href="https://courses.cs.washington.edu/courses/cse484/14au/reading/low-level-security-by-example.pdf">i.e., stack overflow, heap overflow, format string, etc.</a>). The figure above shows typical diversion of the control flow through pointer manipulation. Various techniques have been introduced including stack canaries, stack cookies, shadow stack, <strong>ISR</strong> (Instruction Set Randomization) and <strong>DSR</strong> (Data Space Randomization). Finally, defenders focused on constraining the permission of execution in a certain memory region. The model that any memory region cannot hold both write and execute permissions is simple but strong enough to trigger significant reduction of previous attacks.</p> <p>However, memory page protection was defeated by a novel exploitation technique called <em>ret2libc</em>. (<em><a href="http://phrack.org/issues/58/4.html">The Advanced Return-into-lib(c) Exploits </a></em><a href="http://phrack.org/issues/58/4.html">by Nergal</a>) The idea was to reuse the existing code in a executable region in order to transfer control over the target program. Soon the limited function calls in <em>ret2libc</em> made attackers devise more sophisticated ways to execute the arbitrary code they need, that is, <em>return-oriented programming</em> or <em><strong>ROP</strong></em>. Return-oriented programming generalizes the previous idea so that multiple code chunks can be chained together to achieve an exploit, rather than re-using whole functions from shared libraries. Each small piece of code, known as a gadget, performs some simple operation, followed by a control transfer instruction that points to the next gadget to be executed. This technique is powerful enough to bypass existing non-executable memory countermeasures.</p> <p>In response to code reuse attacks, a new defense mechanism, <a href="https://pax.grsecurity.net/docs/aslr.txt">ASLR (Address Space Layout Randomization), was introduced by the PaX Team</a>. It randomizes the address space within virtual memory every time a process is created so that attackers cannot predict the exact code location at runtime. This strategy has raised a considerable bar because the unpredictability of the required code’s location can eventually lead to failure of the exploit code. For these reasons, today major popular commodity operating systems have adopted both non-executable stack and ASLR protections by default to protect against memory corruption vulnerabilities. (<a href="https://support.microsoft.com/en-us/kb/875352">See a detailed description of the DEP feature from Microsoft</a>) Modern CPU architectures also have started to support a special bit.</p> <p>Unfortunately, this seemingly robust solution has been defeated again through the use of memory disclosure vulnerabilities. Once the location of memory could be revealed at runtime, traditional ROP would be available with ease even under full randomization. This means that ROP variants can survive from detection and prevention even under both DEP and ASLR environment. Whereas typical ROP makes use of a series of gadgets ending with ret instructions to transfer control, ROP variants employ indirect addresses such as <em>call</em> and <em>jmp</em> to evade advanced defenses. A variety of studies have been conducted to attempt to reach practical solution from largely two perspectives. </p> <p>The first category falls into <strong>randomization</strong>, which hinders the knowledge of the code layout. The second one focuses on** CFI, control flow integrity,** since the heart of ROP takes full advantage of following unintended control flows with indirect branches. The former approach includes binary instrumentation, compiler-based code regeneration, code transformation as well as address space randomization. The latter restricts indirect control transfers by runtime checking routines using CFG (control flow graphs) acquired in advance. To reduce runtime overhead while monitoring at runtime, tools like <em>kBouncer</em> and <em>ROPecker</em> suggested relaxed constraints with hardware components to effectively catch the moment a ROP attack begins.</p> <p>Another new type of code reuse attacks leverages JIT engines to construct ROP payloads on the fly. Even though JIT ROP needs to run in a specified environment, it is classified as a high threat in that it enables the evasion of all state-of-the-art defense mechanisms that have been introduced lately. Recent demonstration illustrated that a shellcode was launched successfully through a JIT ROP exploit by feeding malicious JavaScript into a web browser. To remedy these attacks, a few tools resilient to JIT ROP have been suggested by disabling direct and indirect memory disclosure channels.</p> <p> </p> <h3 id="3-evolution-of-code-reuse-attacks"><strong>3. Evolution of Code Reuse Attacks</strong></h3> <p><strong>Systemization of New Attack Surface</strong></p> <p>To overcome the limitation of injecting code, adversaries began to target the existing code which is already executable. The <em>ret2libc</em> attack was an initial attempt to divert control flow to existing code. This made it possible to spawn a shell without code injection, only by jumping to the beginning of the desired function call in a OS-provided shared library and thereby bypassing writable XOR executable defenses. However, <em>ret2libc</em> was quite restricted to apply for general exploits because attackers can only call preexisting functions.</p> <p> </p> <p><a href="http://dandylife.net/blog/archives/551/his1"><img src="http://dandylife.net/blog/wp-content/uploads/2016/01/his1.png" alt="his1"/></a></p> <p>Soon they developed a more flexible technique, return-oriented programming, which can be seen as a generalized form of <em>ret2libc</em>. The main objective is to divert the original control flow by only reusing existing code. This approach has remarkably distinctive feature in that code reuse attack adds a new path to the control flow graph (CFG) rather than adding a new node to the CFG in code injection. Instead of injecting arbitrary code, adversary needs to construct any code of her choice by reverse-engineering and static analysis of a given binary. By shifting attack surface, an exploit itself seemingly becomes more complicated but allows for more flexible and powerful attacks. However, this does not necessarily mean code injection has been ended. Conversely, in fact, the attack today often combines code reuse with code injection to execute malicious payload. For example, in Windows, an attacker can bypass existing mitigation and execute the injected code of her choice using <em>VirtualProtect()</em> to configure the permission of a certain memory location.</p> <p>In 2007, Shacham presented the introduction of how ROP actually works for the first time, titled “<em>The geometry of innocent flesh on the bone: ret2libc without function calls (on the x86)</em>”. The building blocks of ROP are short code sequences from functions. It relies on a) unaligned x86 instructions, b) extremely dense x86 instruction set architecture (ISA). The goal is to find sequences ending with ret or 0xC3. Many gadgets (i.e., 5,483 out of 975,626 in 1.13MB binaries) were found for essential operations such as load/store, control flow, arithmetic, logic, and system calls. It is proved to be feasible to find useful gadgets in existing code space, which allows an attacker to offer the execution of arbitrary codes without injecting a single code at all. </p> <p>Researchers have shown that ROP poses a severe threat in various platforms: SPARC, embedded systems, and even kernel. A framework has been suggested to automate architecture-independent gadget search. The algorithm is capable of locating a Turing-complete gadget set, while translating machine code into an intermediate language allows for minimal architecture-dependent adjustments. Schwartz et al. released Q, which helps to automatically generate ROP payloads for binaries. It shows how hardening exploits to bypass modern defense mechanism comes in handy. Mona is also another gadget generation tool to help ROP automation. Tran et al. demonstrate that the first form of <em>ret2libc</em> can be indeed Turing complete technique, therefore identical in expressive power to ROP. The idea is that it combines existing libc functions to construct arbitrary computations. Furthermore, well-defined semantics of libc allows an adversary to maintain compatible attacks among different families of OSes.</p> <p> </p> <p><strong>Hardening the Attack Vector inside W XOR X and ASLR</strong></p> <p>Although it is obvious that the combination of <strong>W XOR X</strong> and <strong>ASLR</strong> severely impedes traditional memory corruption attacks including code reuse exploits, there are several drawbacks to defeat them. First off, relative distances between memory objects still remain intact in ASLR. Layouts of stack and library table remain the same as well. Secondly, it is still guessable by brute force attack in low entropy such as 32-bit machine. A previous research shows the maximum possible entropy allowed by the virtual memory space does not provide sufficient randomization against brute-force or de-randomization. It said the user mode ASLR on 32-bit architectures only left 16 bit of randomness. Third, research shows that ASLR has not been fully adopted yet. Only 2 out of 16 among popular third-party applications in Windows supported ASLR. Only 5% (66 out of 1,298) binaries in /usr/bin used ASLR in Ubuntu Linux. It appears that performance degradation makes it less preferable to be widely accepted. Payer found that the overhead and side-effects of PIE (Position Independent Executable) was up to 26% with an average of 10% due to the increased register pressure. Lastly, information leak thwarts ASLR by enabling the calculation of the base address at runtime. It is often said to be a vital requirement for successful ROP exploits, leading more advanced code reuse attacks in the long run. </p> <p> </p> <p><a href="http://dandylife.net/blog/archives/551/his2"><img src="http://dandylife.net/blog/wp-content/uploads/2016/01/his2.png" alt="his2"/></a></p> <p>Taking advantage of shortcomings, the technique to bypass PaX ASLR protection has been issued for the first time. It shows that a pointer can be successfully modified to point to a nearby address, by overwriting the least significant byte or bytes of a pointer. Wei et al. demonstrated that de-randomization can be feasible by simply stuffing heap with large objects and multiple copies of attack payload with heap spraying (or JIT spraying) technique. JIT compilation often implements Dynamic Code Generation (DCG), a.k.a Runtime Code Generation. (i.e., <em>JavaScript, Flash, SilverLight</em>). It constructs an x86 instruction flow which might have completely different semantic when executing with a couple of byte offsets. Using this property, JIT begins to be misused by code reuse exploit later on.</p> <p> </p> <p><strong>Information Leaks</strong></p> <p>Information leaks in code reuse attacks refer to the disclosure of a memory address in the virtual address space of a given application at runtime. Once an attacker can obtain the address of specific area, this knowledge allows her to infer additional information that helps to mount a control flow hijacking attack. Today it is regarded as an essential element to mount a successful exploit even under full randomization.</p> <p>A <em>Pwn2Own</em> winner, Dutch hacker, successfully demonstrated an exploit against a fully patched Internet Explorer 8 in 64-bit Windows 7. He bypassed ASLR with a heap overflow to get the address of a dll file in a browser and evaded DEP after an use-after-free vulnerability. After this, diverse vulnerabilities have been reported with the help of memory disclosure. demonstrated that an adversary is able to learn precise information about randomized memory layout of the kernel through timing side channel on modern operating system. They took advantage of the fact that shared resources between user and kernel space can be abused to construct a side channel to reveal memory hierarchy.</p> <p> </p> <p><strong>Bypassing Cutting-Edge Defenses</strong></p> <p>As various defenses mechanisms have been proposed, based on randomization and CFI, attackers have also demonstrated that new strategies can be followed to circumvent cutting-edge defenses. Checkoway et al. showed that ROP attacks can be feasible without <em>ret</em> instructions. Instead they employed indirect flow instructions such as <em>call</em> and <em>jmp</em>, that behave like a return. They mentioned that a new method would have negative implications against several defense proposals using detection of frequent returns or compiler modification. Similarly, an alternative attack paradigm, jump-oriented programming, has been introduced. It eliminates the reliance on the stack and <em>ret</em> instructions including return-like ones like <em>pop+jmp</em>. In order to govern the execution control without <em>ret</em>, it uses the dispatcher gadget that determines which functional gadget would be invoked the next.</p> <p>Late studies insist that ROP is still non-trivial by showing the circumvention against a series of state-of-the art defense mechanisms. Goktas et al. evaluated cutting-edge CFI techniques and exploited looser notion of CFI in particular by claiming two main issues: a) an ideal CFI is too expensive for deployment and b) it requires additional data like source code or debug information, which is often unavailable to commercial products. One example method was <em><strong>call-oriented programming (COP)</strong></em> while chaining gadgets. Concurrently but independently, Carlini et al. successfully bypassed two modern defenses by violating assumptions in <strong><em>kBouncer</em> **and **<em>ROPecker</em></strong>. They demonstrated that call-preceded gadgets are sufficient for exploitable payload. Moreover, the two assumptions based on ROP observation was incorrect thus bypassable as followings: a) all return instructions target call-preceded addresses, but using call-preceded gadgets can defeat it; b) ROP attacks are built of long sequences of short gadgets, but large no-operation gadgets could successfully circumvent it. In the same context, Goktas et al. pointed out that a heuristic-based policy with CFI can be thwarted by carefully-crafted-gadgets. It mainly relies on two threshold parameters: the length of the individual gadget (LG) and the length of gadget chain. (LC). Although the larger LG and the smaller LC is preferred to hinder attack success, setting too large LG and too small LC increases false positives. Both <em>kBouncer</em> and <em>ROPecker</em> picked the thresholds (LG and LC) as 20 and 8, and 6 and 11 based on heuristics respectively. However, it turns out finding the right size appears to be fairly challenging at the intersection of true positive and false positive. Bittau et al. discovered a novel way to remotely find ROP gadgets (Blind ROP or <strong>BROP</strong>), and to automatically construct an exploit against a specific platform (i.e., nginx, yaSSL and MySQL in 64-bit Linux).</p> <p> </p> <h3 id="4-evolution-of-code-reusedefenses"><strong>4. Evolution of Code Reuse Defenses</strong></h3> <p>As code reuse attacks have become a popular exploitation technique to employ for memory corruption vulnerabilities, a great deal of research has been performed in both academia and industry. The techniques introduced in these studies fall into predominately two categories: a) randomization, and b) control flow integrity (CFI). The first group focuses on the predictability of the address space for an adversary. This observation has attempted to break the knowledge of code layout by introducing artificial diversity with the help of randomization technique. Another group has pinpointed that the apex of the code reuse attack has to benefit from corrupted control flow. This observation strives to restrict the use of indirect branches against control flow hijacking and thus to achieve control flow integrity. This section covers how two approaches have evolved to resolve the attack and what are their strengths and weaknesses.</p> <p> </p> <p><a href="http://dandylife.net/blog/archives/551/his3"><img src="http://dandylife.net/blog/wp-content/uploads/2016/01/his3.png" alt="his3"/></a></p> <p> </p> <p><strong>Randomization: Address Space</strong></p> <p>The credit of the initial idea for randomization goes back in 2001 from PaX Team. They suggested the scheme, address space layout randomization or ASLR, whose main objective is randomize base addresses of memory segments at every invocation so that an attacker cannot predict the absolute addresses for exploit purpose.</p> <p>Early research in address space randomization was explored by Bhatkar et al., which developed so-called address obfuscation that randomizes the location of data and code section. It also used code diversification in their implementation as well. </p> <p>Verified with reasonable performance in implementation, ASLR has started to be widely adopted by major modern operating systems. Linux kernel has implemented ASLR by default since the released version 2.6.12 in 2005, which affects both executables and shared libraries to randomize address space. Linux also offered the feature to enable a PIE (Position-Independent Executable) option in compile time so that a binary can be mapped into a virtual address with a random base at runtime even earlier than ASLR. Microsoft Windows has released Vista version at the form of opt-in ASLR for compatibility issues with old applications in early 2007. It allows for the randomization of locations including stack, heap, PEB (Process Environment Block) and TEB (Thread Environment Block). Windows 7 or later version supports ASLR by default. Microsoft has released the tool since 2009, the Enhanced Mitigation Experience Toolkit or EMET, to enforce randomization in case of statically-mapped DLLs even under ASLR-enabled environment. Followed by Windows, Apple also introduced Mac OS X Leopard 10.5 in late 2007, which supports randomization for system libraries. They extended ASLR implementation to all applications from Mac OS X Lion 10.7 and iOS 4.3 for mobile platform since 2011. As shown above, the goal of ASR technique aims to mitigate control-flow hijacking attacks by randomizing the location of code and data and thereby to hamper address predictability with high probability. However, due to several drawbacks like insufficient entropy, more fine-grained randomization technique needs to be brought up.</p> <p> </p> <p><strong>Randomization: Code Diversification (Transformation)</strong></p> <p>The fundamental distinction in code diversification technique from ASR is that it transforms the original code without breaking intended semantics of the program by rewriting a target binary. It tries to achieve fine-grained ASLR in various granularities: reordering/substitution within a basic block, function-level randomization, instruction-level randomization, and permutation of basic blocks. Note that binary rewriting often requires additional information to preserve the semantics such as source code for re-compilation, debugging symbols, relocation information and disassembly with control flow graph.</p> <p>The first attempt of code transformation can be found in address obfuscation technique for user applications, which includes the aforementioned ASLR from a kernel level. To this end, a) it randomizes the base addresses of stack, heap, DLL, text and data segments, b) it permutes the order of variables and routines, and c) it introduces random gaps between objects such as stack frame padding between the base pointer and local variables, random padding between successive <em>malloc</em> allocation requests and between variables, spaces within routines and so forth. This requires both an accurate control-flow graph and a full rewriting of all the routines for full feature-enabled implementation. Another mitigation tool has also been made assuming source code is available. The transformation covers static data, code, stack, heap and DLL. Even though its effectiveness and entropy was sufficient in practice, but the overhead was somewhat high (11% on average) and was inapplicable in general for the binaries away from revealing source code.</p> <p>Chongkyung et al. proposed the binary rewriting tool, address space layout permutation (<strong>ASLP</strong>) [19]. It places the static code and data segments to a random location and performs function-level permutation up to 29 bits of randomness on a 32-bit architecture. However, ASLP does not support stack frame randomization thus it is vulnerable to a <em>ret2libc</em> attack. Unless relocation information is available in a binary, it may require re-linking and re-compiling process which makes it less practical for most COTS products.</p> <p>Another attempt of code transformation is <strong>In-Place Code Randomization</strong> or <strong>IPR</strong>. It introduces four randomization techniques: a) instruction substitution; b) intra basic block instruction reordering; c) instruction reordering with register preservation code; and d) register reassignment. IPR practically has no overhead because it uses exactly the identical instructions while transformation process. It also requires no source code or debug symbols, but it relies on the accuracy of disassembly to draw control flow graph in advance. As authors mentioned, it is difficult to decide if the remaining gadgets would be sufficient to construct useful gadgets. Additionally, it might not be applicable for software that performs self-checksumming or runtime code integrity checks. Behind some of drawbacks, this technique could break around 80% of gadgets on average with negligible overhead. Their evaluation shows that several known exploits were successfully broken by ROP code generating tools such as Q and Mona. </p> <p> </p> <p>Jason Hiser et al. suggested another approach, named Instruction Location Randomization or <strong>ILR</strong>, which attempted to break priori knowledge of ROP gadget locations. In a nutshell, it statically randomizes most instruction addresses and dynamically using control flow in a virtual machine (VM). To achieve this goal, ILR takes arbitrary binary as an input into disassembly engine and does both indirect branch target analysis and call site analysis. Then it rewrites the rules by reassembly engine, using them when instructions are being fetched inside ILR VM. Meanwhile, this technique leads to inevitably higher overhead (13% on average) with VM as well as space overhead (104MB of rule files on average). In addition, gadgets will be remained because there are indirect branch targets which cannot be moved. The security of VM itself has to be guaranteed to safely apply to this technique.</p> <p>Binary stirring (<strong>STIR</strong>) has been proposed by Wartell et. al. Its high-level architecture includes static rewriting and stirring at load time. It transforms legacy x86 application binaries into self-randomizing instruction addresses without source code or debug information. Then STIR statically randomizes basic blocks in each invocation at load time. Although this method attains high effectiveness in removing gadgets (99.99%) with low overhead (1.6% on average), the authors had to duplicate the code section to avoid misinterpretation (i.e., converting code into data or vice versa) by design in a conservative way, which ends up with space overhead (73% on average). However, it focuses on the main module of the application rather than dynamic linked libraries in Windows or shared objects (SOs) in Linux. This results in the failure of abundant gadgets in those files. Moreover, STIR cannot protect control-flow hijacking when calling a legitimate computed jump target with corrupted arguments.</p> <p>Lately Davi et al. implemented another rewriting solution to mitigate code reuse attacks, called <strong>XIFER</strong>. By comparing with previous works, it tries to balance out a tradeoff between functionality and efficiency by defining ten criteria and properties: effectiveness, entropy, randomization frequency, required information, coverage, performance and so forth. XIFER is a on-the-fly rewriter at the form of shared library applied the principle of code diversity. Its overhead with SPEC2006 experiments showed only 1.2% on average at runtime. However, this tool also relies on the accuracy of disassembly and building the reference graph.</p> <p> </p> <p><strong>Control-Flow Integrity: Static checks</strong></p> <p>As alluded above, static CFI checking confines execution flow within the boundary of allowed control paths, focusing on statically determining the valid targets (i.e., calls, function returns) A number of attempts have been made, applying relaxed policy for the integrity of indirect control transfers. </p> <p>Researchers have introduced the compiler to be able to eliminate gadgets. <strong>Return-less kernel</strong> has been developed on a LLVM-based prototype and used it to generate a return-less kernel in FreeBSD. <strong>G-Free</strong> removes gadgets from binaries at compile time by eliminating all unaligned free-branch instructions and by protecting the remaining aligned free-branch instructions. In particular, when generating an executable, it avoids ret instructions and various opcodes that can be used in gadgets. Extending the LLVM compiler, <strong>Control-Flow Restrictor</strong>, also has been implemented to add CFI enforcement during compilation time of a given application in Apple’s iOS. The shortcoming of compiler-based approaches is that it requires source code and it should be applied to all modules to be effective. (i.e., using a crafted compiler)</p> <p>Another idea is to enforce CFI on binary programs without recompilation. Mingwei et al. presented a novel way to apply CFI to stripped binaries without source code, compiler support, debugging information or the presence of relocation. They developed robust techniques for disassembly, static analysis and transformation of a given binary, which can work even for complex COTS products against control flow hijacking. However, it cannot eliminate the <em>ret2libc</em> attack since it follows the original control flow with no violation. Obfuscated code can’t be covered either because it is quite challenging to obtain reliable static disassembly. The runtime overhead was 4.29% on average, while the space overhead was 1.39 times larger than the original file size on average.</p> <p>Zhang et al. proposed <strong>CCFIR</strong> (Compact Control Flow Integrity and Randomization) to address both performance and compatibility issues in practice. It uses both CFI and binary transformation technique. CCFIR collects all legitimate indirect control flow instructions and limits jumps to anywhere but known locations. The gathered-white-list facilitates random permutation to raise the bar against hijacking likelihood. Binary transformation depends on relocation tables only rather than source code or debug information. The legitimacy checks took reasonable overhead. (3.6% on average)</p> <p> </p> <p><strong>Control Flow Integrity: Dynamic Checks</strong></p> <p>Another viewpoint has focused on mitigating ROP exploits by monitoring program execution at runtime rather than at compile time or load time. An early research which applied dynamic CFI checking at runtime is <strong>DROP</strong>. It aims to detect malicious code build using ROP. By looking at ret instructions, it records the popped addresses and check if those are within libc and check out the length of each gadget and the maximum length of continuous candidate gadgets. Although the limitation is obvious since DROP cannot detect short sequence of gadgets (i.e., less than 3) and only detect the gadgets from libc ending with a ret instruction. The performance overhead under DROP was 5 times slower on average, up to 21 times, which made it impractical in use. <strong>DynIMA</strong> was proposed as a runtime monitoring architecture. It is the first attempt to prevent ROP with the help of Trusted Computing mechanism which verifies the integrity of executables in an operating system. However, it suffers from performance mostly during dynamic taint analysis that marks any untrusted data as tainted and traces the propagation of tainted data.</p> <p>Another novel idea has been suggested with the concept of <strong>locking</strong>. Like mutex, the lock asserts the correctness of the control flow of the application by inserting a lock code. This code represents the lock by simply changing a certain value in memory. Only valid destination can unlock the corresponding lock. Otherwise the violation of control flow would be detected, leading to make the program aborted. </p> <p> </p> <p>Meanwhile, several coarse-grained CFI techniques have been introduced. Davi et al. presented another ROP detection tool, <strong>ROPdefender</strong> to defend against ROP. It uses dynamic binary instrumentation (DBI) to keep a shadow stack that is updated by instrumenting call and ret instructions. If ROPdefender detects a unexpected call-ret pair by comparison with the address placed on a shadow stack, it thwarts further execution. But one of shortcomings was that it did not protect any gadgets ending with indirect jmp or call instructions. Besides, additional instrumentation imposes significant overheads (2x on average) to hinder the applicability in practice.</p> <p> </p> <p><strong>ROPGuard</strong> focused on the observation that critical API functions would be invoked to launch successful attack. To be specific, for each critical function at runtime, it verifies if the return address is executable, the instruction at return address is preceded with a call instruction, and call instruction goes back to the current function. The idea was worth enough to protect many known ROP exploits in the wild. It has been integrated with Microsoft EMET tool. Kayaalp et. al proposed so-called BR or branch regulation. It enforces control flow rules at the function granularity against ROP exploit. Instead of constructing the whole CFG, BR checks only unintended branches. This property is efficient to common ROP and JOP attacks but it limits the protection against <em>ret2libc</em> that follows control flow. The overhead was acceptable. (around 2% on average)</p> <p>As coarse-grained CFI suffers from the limitation of protection against ROP as well as severe overhead, fine grained CFI has been introduced. To overcome performance degradation, state-of-the-art defense mechanisms started to adopt hardware-support feature such as branch tracing store (BTS) and Last Branch Record (LBR). Modern CPU supports a built-in performance monitoring unit (PMU) for the purpose of measuring its performance parameters such as instruction cycles, cache hits, cache misses and so on. PMU includes BTS, LBR, event filtering, conditional counting and so forth. Using hardware-support functionality compensates for the practical drawbacks of the original CFI perspective.</p> <p>For the first time, <strong>CFIMon</strong> leverages the BTS mechanism to analyze runtime traces on-the-fly. It collects legitimate control transfers and detect violation of CFI accordingly. However, CFIMon might lead false positives and false negatives. To date, one of cutting-edge detection mechanism, <strong>kBouncer</strong> has been demonstrated by Pappas et al. It leverages LBR to keep track of branch history, which allows for transparent operation and minimum runtime overhead. (1% on average) Another similar approach has suggested <strong>ROPecker</strong> by Cheng et al, taking advantage of LBR as well [18]. Both kBouncer and ROPecker observed two significant thresholds at the moment of successful ROP attacks. One is gadget chain and the other one is gadget size. Heuristically, the former sets the maximum amount of gadget chain to 20 and the tolerable value of gadget size to 8 by default. The latter sets them to 6 and 11 respectively. The shorter gadget chain or the longer gadget size makes an adversary harder to construct exploitable payload in the end. Thus one can say ROPecker has more strict CFI policy than kBouncer. However, both defense mechanisms largely rely on the very limited size of the LBR stack, which holds only 16 records. The benefit of these solutions has been again defeated by relaxed assumptions and the aforementioned limitation. They pointed out heuristic itself cannot be the ultimate solution. They demonstrated many different evasion techniques and niche attack vectors such as NOP operation gadget, long gadget, and call-preceded gadget to nullify the state-of-the-art defense mechanisms. </p> <p> </p> <p>Another novel attempt was made to harden even ASLR-disabled binaries stripped off the relocation information during compilation. As executable files that do not carry relocation information cannot be loaded into the preferred base address in Windows, it is often seen that it is specified at link time. Under this environment, they monitor memory accesses and control flow transfers with page table manipulation at runtime. In other words, the technique relies on the reconstruction of missing relocation information by discovering appropriate relocatable offsets on the fly. The study sheds light on the feasibility to expand the protection towards legacy binary which does not take advantage of ASLR.</p> <p>Lastly, Payer et al. presented <strong>Lockdown</strong>, that protects binary-only applications and libraries by rewriting them. During runtime, Lockdown adjusts the CFG by growing and shrinking its size as executing new code and unloading libraries respectively. It also employs a shadow stack to enforce the strict integrity of <em>ret</em> instruction pointers, which only allows the return to target the actual caller. The performance overhead was 19% on average.</p>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Attack &amp;amp; Defense, Cyber Warfare"/><category term="code reuse"/><category term="rop"/><summary type="html"><![CDATA[1. Introduction]]></summary></entry><entry><title type="html">Internet Censorship</title><link href="https://kevinkoo001.github.io/blog/2015/internet-censorship/" rel="alternate" type="text/html" title="Internet Censorship"/><published>2015-10-28T06:14:58+00:00</published><updated>2015-10-28T06:14:58+00:00</updated><id>https://kevinkoo001.github.io/blog/2015/internet-censorship</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2015/internet-censorship/"><![CDATA[<p><strong>1. Overview of Internet censorship</strong></p> <p>이제 인터넷은 일상 속의 일부가 된 지 꽤 오래다. 가상환경이라는 말이 무색하게 우리 생활에 깊이 관여하면서 지역, 사회, 국가, 시공간을 초월하여 정보를 얻을 수 있는 편리한 도구로 자리잡았다.  하지만 무수히 많은 정보 중 다양한 이유로 (문화, 관례, 관습, 종교, 정치 등) 특정한 정보를 탐탁치 않게 생각하는 세력이 있고 이를 조직, 이익단체, 회사, 정당, 또는 국가차원에서 일반인이 쉽게 접근할 수 없도록 검열(censorship)하기 시작했다.</p> <p>일반적으로 검열이란 단어, 이미지, 생각 등을 억제하는 그 자체 또는 방법까지 포함하는 의미라고 볼 수 있다. 온라인에서 Censorship은 기술적으로 네트워크 계층 상단에서 종종 이뤄진다. 인터넷 이전에는 유선전화 선로를 물리적으로 단절하거나 신호를 방해하는 형태로(radio jamming이나 broadcast disruption) 가능했었다. 가장 간편한 방법은 인터넷 라인을 끊어버리는 것이지만, 국가 차원의 망을 AS 단위로 완전히 통제하지 않는 이상 IP의 Packet switching 특성 때문에 routing 경로는 다양할 수 밖에 없도록 설계되어 있다.  TCP/IP를 표준으로 사용하는 현대의 censorship은 크게 IP Layer에서 IP를 차단하거나 경로를 강제 우회하는 방식, TCP Layer에서 접속을 방해하는 방식, DNS 프로토콜 동작을 오용하는 방식,  그리고 Application Layer에서 사실상 정보교환의 표준이 된 HTTP 프로토콜에서 URL 접근차단이나 우회 등으로 나눌 수 있다.</p> <p><strong>2. Censorship at IP Layer</strong></p> <p>IP 계층에서 접속제한은 두 가지로 볼 수 있다.</p> <p>첫째는 IP 주소자체에 대한 <strong>접근통제 목록 (ACL; Access Control List)</strong>을 router나 방화벽(firewall) 등 가능한 장비에 설정하는 방식이다. Router에서 Blackhole routing 설정도 같은 맥락이다. 이는 상당히 간편한 configuration으로 - <a href="https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing">CIDR (Classless Inter-Domain Routing)</a> 등을 통해 - IP mapping이 가능하다는 장점이 있으나, 해당 IP를 일일히 조회해야 하는 번거로움이 있다. 설령 이를 자동화한다 해도 IP 자체 Blocking은 의도치 않게 개별이 아닌 NAT를 사용하는 조직이나 기관 단위 전체가 대상이 되어 버릴 수도 있고, Proxy를 통한 우회도 매우 쉽다. 또한 복수 개의 Host가 하나의 IP를 사용하는 경우에도 원하지 않는 차단이 이뤄질 수 있다. 영국같은 경우 해적 사이트의 경우 Proxy까지 아예 막기 시작했다. (<a href="https://torrentfreak.com/uk-isps-quietly-block-lists-of-pirate-bay-proxies-150310/">관련기사</a>)</p> <p>둘째는 BGP (Border Gateway Protocol)를 이용해 주변 <a href="https://en.wikipedia.org/wiki/Autonomous_system_(Internet)">AS (Autonomous system)</a>에 <strong>가짜 경로 정보(bogus route)</strong>를 뿌리는(advertise) 방식이다. 비록 의도하지 않았지만, 가장 악명높은 BGP 오용 사례 중 하나는 파키스탄 정부가 소유한 국영통신업체 <a href="http://www.pta.gov.pk/">PTA (Pakistan Telecommunication Authority)</a>에서 특정 IP를 단속하고자 Youtube가 소유한 한 C Class 단위의 IP 대역을 neighbor AS에 가짜 정보를 흘린 (hijacking) 사고다. 당시 Youtube는 208.65.153.0/22 대역을 소유하고 있었는데, PTA AS (17557)에서 해당 IP대역 24 bit가 본인이 소유하고 있다고 거짓으로 알렸고 (announce), 이 정보를 받은 AS가 인접 AS에 퍼뜨리면서 수 분 내로 전 세계의 Youtube 트래픽 (AS 36561) 이 PTA로 몰리기 시작했다. 물론 PTA는 해당 IP를 블랙홀 처리했기 때문에 당연히 접속히 불가능했다. 아래 동영상을 보면 어떻게 해당 route 정보가 전파되었는지 알 수 있다. 시간대별로 세부 정보는 <a href="http://research.dyn.com/2008/02/pakistan-hijacks-youtube-1/">여기</a>에서 확인할 수 있다.</p> <p>[youtube https://www.youtube.com/watch?v=IzLPKuAOe50]</p> <p>이는 프로토콜 자체로 보면 매우 정상적인 행위인데, 바로 BGP announce는 더 상세한 prefix를 참조 (longest prefix match)하는 규칙을 따르고 있기 때문이다. 또한 놀랍게도 BGP에는 이웃 AS에게 route 정보를 송수신할 때 인증(authentication) 메커니즘이 없다. 이처럼 국지적인 행위가 전세계에 부정적인 영향을 미치는 형태를 ‘<strong><a href="https://en.wikipedia.org/wiki/Collateral_damage">부수적인 피해 (Collateral Damage)</a></strong>‘라고 한다.</p> <p><strong>3. Censorship at TCP Layer</strong></p> <p>TCP 계층은 <strong>RST 패킷</strong>을 이용하는 방법이 일반적이다. 사실 RST Packet은 정상적인 통신규약의 일부로 해당 연결에서 목적지(destination)가 더 이상의 데이터가 가용하지 않을 때나 출발지(source)에서 데이터를 더 이상 받지 않으려 할 때 보낸다. 실제 전체 flow의 10-15% 정도가 FIN이 아닌 RST으로 접속을 종료(termination)한다고 알려져 있다.</p> <p>Censorship 용도로 RST을 전송해 접속을 강제로 끊는 경우 설치 위치에 따라 흔히 두 가지 유형으로 나눈다. 하나는 <strong>인라인</strong> (<strong>in-path</strong>) 또는 <strong>경로 내부</strong>에 설치해서 모든 패킷을 직접 관통하게 해서 검열하는 방식이다. 다른 하나는 감청장치(wiretap)를 이용해 패킷을 포워딩(forwarding)한 후 감시하면서 대상(target)이 보일 때 RST을 전송하도록 <strong>경로 외부</strong>에 (<strong>on-path 또는 out-of-path</strong>) 설치하는 방식이다. 전자는 모든 패킷에 직접적으로 관여하므로 패킷을 없애거나 (drop) 주입(injection)함으로써 능동적으로 통제를 하기 쉽다는 장점이 있다. 하지만 단일 실패점 (Single Point of Failure)으로 검열에 실패할 가능성도 존재하고, 트래픽 증가에 따른 확장성(scalability)도 용이하지 않다. 반대로 후자의 경우 간접적으로 관여하므로 훨씬 안정적으로 운영할 수 있고 병렬처리가 가능한 장점이 있는 대신, Censor가 직접 Packet을 제거(removal)하거나 조작/변경 (manipulation 또는 replacement)하기는 불가능하다. 다시 말해 클라이언트는 실제 서버에서 전송한 메시지를 결국 수신하게 된다는 의미다. 경로 외부 설치는 안정적인 운영이라는 장점 때문에 현장에서 IDS (Intrusion Detection System)나 DPI (Deep Packet Inspection)에 많이 사용하고 있는 실정이다.</p> <p>그럼 On-path 방식을 좀 더 살펴보자. 직접적인 패킷 조작이 불가하므로 이 형태의 censorship이 신뢰할 만한 수준 (reliable)에서 동작한다면, 항상 탐지 가능(detectable)하다. 또한 어떤 방식으로 검열하고 있는지 그 메커니즘까지 알 수 있다. 그 이유는 On-path 검열장비는 결코 상대 (endpoint) 로부터 오는 응답 (response)를 완벽히 재현할(mimic) 수 없기 때문이다. 예를 들어 censor 장비에서 오는 TTL 값은 실제 상대가 송신하는 응답과는 다를 수 밖에 없다. 또한 송신자가 기대하는 다음 패킷의 sequence 번호는 자신이 보낸 번호와 패킷 길이를 더한 값이어야 하지만, censor 장비가 보낸 패킷은 이를 흉내낸다 하더라도 수신자가 최소 두 번을 받게 될 것이다. 패킷 왕복 시간 (RTT, Round Trip Time) 역시 차이가 날 것이다.</p> <p>여기서 <strong>경쟁조건 (race condition)</strong>이 필히 발생하는데, 하나는 RST 패킷을 받고 난 이후 Data를 받는 경우, 또 하나는 Data를 받고 나서 RST를 받는 경우다. 전자는 수신자 입장에서 이상하게 보일 테고 (out of specification) - 그래도 연결은 끊어진다 - 후자는 이미 Data를 수신했으므로 RST을 무시해 (ignore) 버릴 것이다. 이런 이유로 중국의 검열장비(Great Firewall of China)는 성공율을 높이기 위해 RST을 정확히 세 번 보낸다. Richard는 <a href="http://www.cl.cam.ac.uk/~rnc1/ignoring.pdf">Ignoring the Great Firewall of China</a>라는 논문에서 클라이언트와 서버 양단에서 RST을 모두 무시할 경우 RST 패킷을 보내는 경우에도 성공적으로 접속할 수 있다는 결과를 내놓았다.</p> <p><strong>4. Censorship at DNS</strong></p> <p>DNS (Domain Name System) 는 도메인 명(Domain name)을 IP로 변환해 주기 위해 계층적으로 (Hierarchical) 위임하는 구조로 질의할 수 있는 시스템이다. 클라이언트는 Local DNS 서버에 질의를 하는데, 이 서버를 stub resolver 또는 non-authoritative resolver라고 한다. Local DNS는 우선 자신의 cache에 해당 정보가 있는지 검색한 후 없으면 차례로 root DNS, TLD (Top Level Domain) DNS로 질의한 후 결국 해당정보를 가진 최종 authoritative resolver에게 질의해서 응답을 받게 된다.</p> <p>아래의 경우 구글 DNS (8.8.8.8)에 질의한 결과 Root ‘e’ 서버와 d.gtld-servers.net라는 TLD 서버로부터 recursive하게 정보를 받아 authoritative server인 ns1.newt.arvixe.com에게 결국 dandylife.net의 IP를 받아오는 모습을 볼 수 있다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dig @8.8.8.8 dandylife.net +trace

; &lt;&lt;&gt;&gt; DiG 9.7.3 &lt;&lt;&gt;&gt; @8.8.8.8 dandylife.net +trace
; (1 server found)
;; global options: +cmd
.                       8060    IN      NS      a.root-servers.net.
.                       8060    IN      NS      b.root-servers.net.
.                       8060    IN      NS      c.root-servers.net.
.                       8060    IN      NS      d.root-servers.net.
.                       8060    IN      NS      e.root-servers.net.
.                       8060    IN      NS      f.root-servers.net.
.                       8060    IN      NS      g.root-servers.net.
.                       8060    IN      NS      h.root-servers.net.
.                       8060    IN      NS      i.root-servers.net.
.                       8060    IN      NS      j.root-servers.net.
.                       8060    IN      NS      k.root-servers.net.
.                       8060    IN      NS      l.root-servers.net.
.                       8060    IN      NS      m.root-servers.net.
;; Received 228 bytes from 8.8.8.8#53(8.8.8.8) in 14 ms

net.                    172800  IN      NS      d.gtld-servers.net.
net.                    172800  IN      NS      a.gtld-servers.net.
net.                    172800  IN      NS      g.gtld-servers.net.
net.                    172800  IN      NS      m.gtld-servers.net.
net.                    172800  IN      NS      b.gtld-servers.net.
net.                    172800  IN      NS      e.gtld-servers.net.
net.                    172800  IN      NS      j.gtld-servers.net.
net.                    172800  IN      NS      i.gtld-servers.net.
net.                    172800  IN      NS      f.gtld-servers.net.
net.                    172800  IN      NS      l.gtld-servers.net.
net.                    172800  IN      NS      c.gtld-servers.net.
net.                    172800  IN      NS      k.gtld-servers.net.
net.                    172800  IN      NS      h.gtld-servers.net.
;; Received 500 bytes from 192.203.230.10#53(e.root-servers.net) in 107 ms

dandylife.net.          172800  IN      NS      ns1.newt.arvixe.com.
dandylife.net.          172800  IN      NS      ns2.newt.arvixe.com.
;; Received 114 bytes from 192.31.80.30#53(d.gtld-servers.net) in 36 ms

dandylife.net. 86400 IN A 143.95.249.220
dandylife.net. 86400 IN NS ns1.arvixeshared.com.
dandylife.net. 86400 IN NS ns2.arvixeshared.com.
;; Received 99 bytes from 169.55.246.167#53(ns1.newt.arvixe.com) in 54 ms
</code></pre></div></div> <p>여기서 DNS의 문제를 발견할 수 있는데, 바로 매번 질의하기 번거로우므로 일정시간 동안 non-authoritative server의 cache에 저장한다는 점이다. 이 Entry가 잘못되었을 경우 사용자는 Poisoning 공격에 노출된다. 이는 Kaminsky가 2008년 _<strong>DNS Cache poisoning</strong>_이라는 공격을 연구해 발표하면서 정식으로 세상에 알려지게 되었다. 자세한 사항은 <a href="http://unixwiz.net/techtips/iguide-kaminsky-dns-vuln.html">여기</a>를 참조하도록 하자. 멋진 도식과 함께 세부사항까지 잘 설명되어 있다.</p> <p>Censorship을 하는 과정에서도 DNS는 쉽게 이를 악용한 표적이 될 수 있다. 국가나 기관이 DNS를 장악 (compromise)할 수 있다면, 이와 같은 poisoning 공격이나 redirection IP를 알려줄 수 있다. TCP RST과 같은 방식으로 on-path에서 DNS injection 또한 가능한데, 이는 일종의 “<a href="https://en.wikipedia.org/wiki/Man-on-the-side_attack">Man-on-the-side</a>” 공격이라 볼 수 있다. 2012년 SIGCOMM에 익명(anonymous)으로 기고한 한 논문, <a href="http://www.sigcomm.org/sites/default/files/ccr/papers/2012/July/2317307-2317311.pdf"> The Collateral Damage of Internet Censorship by DNS Injection</a>에서 중국 도처에 있는 39개 AS의 Censorship으로 인해 다른 국가가 얼마나 피해를 입고 있는지에 대한 연구결과를 내놓았다.  중국에 위치한 루트 DNS 서버인 F, I, J 때문에 일부 TLD 서버가 중국의 ISP를 경유할 때 제대로 된 DNS 응답을 받지 못한다는 것이다. 한국도 사실 영향권에 있으며 독일 쪽 서버와 통신할 때 피해를 입고 있음을 알 수 있다.</p> <p>가짜 DNS 응답을 우회(evade)하는 연구도 있었다. Haixin은 2012년 _<strong>Hold-on</strong>_이라는 기법을 그의 논문에서, <a href="http://conferences.npl.co.uk/satin/papers/satin2012-Duan.pdf">Hold-On: Protecting Against On-Path DNS Poisoning</a>, 소개했다. 아이디어는 DNS 응답을 바로 받아 처리하지 말고 일정시간 동안 기다리라는 것이다. On-path의 경우 실제 DNS 응답이 이후에 도착하게 될 것이므로 정상적인 response을 받고 피해를 최소화할 수 있다. 하지만 이 역시 non-authoritative server가 censorship을 행하는 국가 내부에 있는 경우 cache poisoning에 직접적으로 노출될 수 있으므로 적용할 수 없다.</p> <p>DNS 위조 여부를 확인할 수 있는 간편한 방법은 censorship이 적용되지 않은 것으로 알려진 DNS 서버에 직접 질의해서 그 결과를 비교해 보는 것이다. <a href="http://public-dns.tk/nameserver/cn.html">중국 DNS List </a>중 하나를 선택해 차단되어 있는 것으로 알려진 facebook.com을 테스트해 본 결과 다른 응답을 하고 있음을 알 수 있다. 이 역시 DNS에 인증 메커니즘이 없기 때문에 변조가 용이하다. (인증을 포함한 S-BGP나 DNSSEC은 잘 설계된 프로토콜이지만, motivation이나 overhead 등의 문제로 널리 쓰이고 있지는 않다. 이는 이 글에서 논외로 한다.)</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ nslookup
&gt; server 220.231.248.68
Default server: 220.231.248.68
Address: 220.231.248.68#53
&gt; facebook.com
Server:         220.231.248.68
Address:        220.231.248.68#53

Non-authoritative answer:
Name:   facebook.com
Address: 159.106.121.75
&gt; server 8.8.8.8
Default server: 8.8.8.8
Address: 8.8.8.8#53
&gt; facebook.com
Server:         8.8.8.8
Address:        8.8.8.8#53

Non-authoritative answer:
Name:   facebook.com
Address: 31.13.69.197
</code></pre></div></div> <p><strong>5. Censorship at HTTP (Application Layer)</strong></p> <p>마지막으로 Web protocol의 표준인 HTTP에서 censorship을 알아보자. HTTP의 경우 중간에 Proxy를 이용하는 경우가 대부분이다. 표준구성 또한 앞에서 살펴봤듯이 in-path와 on-path가 존재하며, 이로 인한 장단점 또한 유사하다.</p> <p>Web proxy는 메커니즘에 따라 크게 <strong>flow terminating</strong> 방식과 <strong>flow rewriting</strong> 방식이 있다. 전자는 Proxy가 완전히 TCP 연결을 대신하는 방식으로 실제 사용자 입장에서 목적지는 proxy인 셈이다. 또한 서버 입장에서 클라이언트는 proxy가 되며, 이 방식은 표준에 가깝게 많이 사용한다. 어떤 경우 HTTP 헤더를 변조하기도 한다. 후자는 censor가 필요한 내용(content)가 발견될 경우에만 변경하는 방식으로 구현, 탐지가 모두 어렵다.  censor 대상에 따라 나눈다면, 완전(complete) proxy와 부분(partial) proxy로 나눌 수 있다. 전자는 모든 트래픽을 다 통과시키는데 반해 후자는 특정 IP에 대해서 rerouting하는 방식이다.</p> <p>사실 SSL/TLS와 같이 암호화된 패킷 역시 proxy의 인증서를 강제로 신뢰하게 해서 연결을 강요한다면, MITM (<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-in-the-Middle</a>) 공격과 같은 형태로 모든 패킷을 평문으로 감시할 수 있다. 사용자 입장에서 브라우저 등에서 목적지 인증서와 맞지 않는다는 경고를 볼 수 있겠지만, 이 또한 브라우저에 강제로 신뢰된 인증서를 설치하는 경우 아무런 제약없이 censor가 가능하다.</p> <p>HTTP를 통제하기 위해 여러국가에서 관찰할 수 있는 몇 가지 censor 방식이 있다. 첫째, 블랙리스트를 정의하고 사용자가 알기 어렵도록 아무런 응답을 주지 않는 것이다. 둘째, 의도하지 않은 사이트로 redirection하는 방식도 있다. 한국에서도 방송통신 심의 위원회와 사이버 경찰청에서 불법유해 사이트를 정의하고 도박, 북한관련, 성인물 등의 컨텐츠를 담은 사이트의 경우 www.warning.or.kr로 이동시킨다. 놀랍게도 Alexa World Ranking 3000위에 육박할 정도로 잦은 방문(?)을 하고 있다. 셋째, 특정 keyword에 대해서만 반응하는 방식이다. 해당 사이트가 사전에 정의한 키워드를 담고 있는 경우 차단한다.</p> <p>서구국가에서 검열이 가능한 URL filtering 제품을 다수 개발했는데, 대표적으로 <a href="http://www.websense.com/">Websense</a>, <a href="https://www.bluecoat.com/">Bluecoat</a>, <a href="http://www.netsweeper.com/">Netsweeper</a>, 그리고 맥아피의 <a href="http://www.mcafee.com/us/products/web-protection.aspx">smartfilter </a>등이 있다. (맥아피는 인텔에 인수됨) 대규모 회사에 근무한 분이라면 한 번쯤 들어봤을 만한 제품군이다. 중동지역에서는 국가 차원에서 이 제품을 구매해 실제 적용한 상태다. 예멘, 시리아에 Websense와 Bluecoat 제품을 수출했으나 최근 연구결과로 인해 이 사실이 알려지게 되자 해당 회사는 업데이트 지원을 중단한 상태다. 특히 인권 운동 등을 방해하기 위해 사용되었다는 사실이 알려져 관련 문의를 했으나, 비난 등을 우려해서인지 답변을 하지 않는 경우도 있었다고 한다.</p> <p><strong>6. Net Neutrality</strong></p> <p>지금까지 대부분 Censorship에 관해서 논의했다. 우회 (bypass)하는 방법 또한 다양하지만, 여기서 다루지는 않겠다.</p> <p>수많은 검열이 현실화되면서 각국에서는 <strong><a href="https://en.wikipedia.org/wiki/Net_neutrality">망 중립성 (net neutrality)</a></strong>에 관해 우려를 표명하기 시작했다. 국가나 ISP에서 모든 데이터를 사용자, 컨텐츠, 사이트, 플랫폼, 애플리케이션, 통신 모드 등에 차별/차등없이 (not discriminately / differentially) 다룰 수 있게 해야 한다는 게 골자다. IP를 발명한 Vint Cerf나 Web의 창시자 Tim Berners Lee도 같은 편에 서 있다. 최근 미국 NSA에서 모든 통신내용을 감청하고 있다는 내용을 폭로한 Edward Snowden도 반대진영에 맞서 싸우고 있으며, 많은 사람들의 호응을 얻고 있다. 아래는 2014년 TED에서 연설한 그의 동영상이다.</p> <p>[youtube]xxEw98fbsXo[/youtube]</p> <p>우리나라 또한 인터넷 검열에서 자유롭지 못하다. <a href="https://en.wikipedia.org/wiki/Censorship_by_country">여기 Wikipedia</a>에  국가별 검열 현황이 잘 나타나 있다. 정치/종교/이해관계/문화/사회 등 여러 가지 이유로 censorship을 시행하고 있지만,  당장 옮고 그름으로 판단하기 어려워 보인다. 마지막으로 Netsweeper에서 제공하는 <strong><a href="http://denypagetests.netsweeper.com/">Deny Page Tests</a></strong>에서 어떤 URL이 Filtering되고 있는지 테스트해 보면 어떨런지.</p>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Network Security"/><category term="Security in Society"/><summary type="html"><![CDATA[1. Overview of Internet censorship]]></summary></entry><entry><title type="html">ROP Mitigation using orp</title><link href="https://kevinkoo001.github.io/blog/2015/rop-mitigation-using-orp/" rel="alternate" type="text/html" title="ROP Mitigation using orp"/><published>2015-03-01T07:03:48+00:00</published><updated>2015-03-01T07:03:48+00:00</updated><id>https://kevinkoo001.github.io/blog/2015/rop-mitigation-using-orp</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2015/rop-mitigation-using-orp/"><![CDATA[<p>바로 이전 포스팅에서 ROP 공격을 완화시킬 수 있는 한 방안인 in-place randomization 기법을 소개했는데, 한 번 testing해 봤다. 이 논문의 저자인 Vasilis Pappas는 그 해 rop 관련 방어기법인 kbouncer를 소개해 MS의 Bluehat에서 상금 20만불을 거머쥐기도 했다. (<a href="http://www.microsoft.com/security/bluehatprize">http://www.microsoft.com/security/bluehatprize</a>/) 여기서 사용하는 <a href="http://nsl.cs.columbia.edu/projects/orp/">orp</a>라는 도구 역시 Vasilis가 디자인한 상당히 강력한 ROP 방어 기법 중 하나다.</p> <p>Return-Oriented Programming은 운영체제에서 임의의 데이터(arbitrary data)를 실행할 수 없도록 NX bit, ASLR, DEP 등 다양한 기법을 동원하더라도 우회할 수 있는 방법 중 하나다.  공격자는 이미 실행할 수 있는 영역에 있는 library (windows DLLs)에서 조각나 있는 byte를 모아 gadget으로 구성한 후, eip와 필요한 register를 이용해 공격에 필요한 연산을 수행할 수 있도록 스택을 꾸미는 게 핵심이다.  ROP는 2008년 Blackhat에서도 <a href="https://www.blackhat.com/presentations/bh-usa-08/Shacham/BH_US_08_Shacham_Return_Oriented_Programming.pdf">Erik Buchanan에 의해 소개</a>되었고 corelan 팀이 2010년 기술한 <a href="https://www.corelan.be/index.php/2010/06/16/exploit-writing-tutorial-part-10-chaining-dep-with-rop-the-rubikstm-cube/">exploit writing tutorial</a>에서 매우 상세히 다루고 있다.</p> <p>기존 연구에서 code randomization, 제어 플로우 무결성을 이용하는 방법도 있지만 이는 소스에 디버깅 정보가 있어야 한다. 또한 runtime 시 체크하는 방법론도 제시되었으나 overhead가 커서 실용적이지 못하다. 이 <a href="http://www.cs.columbia.edu/~vpappas/papers/smash.sp12.pdf">논문</a>의(Smashing the Gadgets: Hindering Return-Oriented Programming Using In-Place Code Randomization) 아이디어는 간단한 편이지만, 방어력은 실용적(practical)이고 효율적(effective)이다. 최종 결과를 보면 전체 gadget으로 이용할 수 있는 코드 중 10% 정도만을 변환해서 80% gadget을 쓸모없게 (useless) 만들었다고 한다.</p> <p>핵심은 파일크기를 전혀 변경하지 않고 기존 code flow를 전혀 손상하지 않은 채로 같은 코드로 전환(transformation)하는 것이다. 즉 기존코드에서 gadget으로 사용할 수 있는 부분을 다음과 같은 세 가지 형태로 변환하는 과정을 거친다.</p> <ul> <li> <p>개별 명령어 치환 (Atomic instruction substitution) 같은 행위를 하는 명령어는 여러 가지 형태로 변형할 수 있음 아래의 경우 같은 연산을 하지만 opcode는 다름 예) add r/m32, r32 ↔ add r32, r/m32 test r/m8, r8 ↔ or r/m8, r8 ↔ or r8, r/m8</p> </li> <li> <p>재배치(reordering): 내부 Basic Block, register 값이 유지되는 레지스터 변경 종속 그래프를 그려서 코드 블록을 재배치함</p> </li> <li> <p>Register 재할당 (reassignment) CFG(Control Flow Graph, 제어 흐름도)를 그려서 상호 간 영향을 미치지 않는 영역(parallel, self-contained regions)을 확인하고 이해 한해서 register를 바꾸는 방법</p> </li> </ul> <p>이 중 첫 번째 단순 치환은 이해하기 쉽다. 다음 코드를 보자.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ORIGINAL]
.text:0700106F 55                push    ebp
.text:07001070 8B EC             mov     ebp, esp
.text:07001072 83 EC 28          sub     esp, 28h

[PATCHED]
.text:0700106F 55                push    ebp
.text:07001070 8B EC             mov     ebp, esp
.text:07001072 83 C4 D8          add     esp, 0FFFFFFD8h
</code></pre></div></div> <p>Highlight 부분인 sub esp, 28h가 add esp, 0FFFFFD8h 로 바뀌었으나 의미는 esp에서 28을 빼거나 -28을 더하라는 것이므로 동일하다.  유사한 방식으로 다음 코드치환도 마찬가지다.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ORIGINAL]
.text:0700110A E8 CE FF FF FF        call    sub_70010DD
.text:0700110F 85 C0                 test    eax, eax

[PATCHED]
.text:0700110A E8 CE FF FF FF        call    sub_70010DD
.text:0700110F 09 C0                 or      eax, eax
</code></pre></div></div> <p>두 번째, 재배치 부분을 보자. (그림은 논문에서 인용했음)</p> <p><a href="http://dandylife.net/blog/wp-content/uploads/2015/03/rop1.png"><img src="http://dandylife.net/blog/wp-content/uploads/2015/03/rop1-1024x262.png" alt="rop1"/></a></p> <p>위 그림은 x86 assembly에서 길이가 유동적인(또는 가변적인) instruction/operand 특성 때문에 여러가지로 해석될 수 있음을 나타낸다. 윗부분은 실제 프로그램 코드를 읽어야 하는 순서를 나타내고 있지만, 내부에 있는 코드를 다르게 잘라 읽으면 아래부분의 gadget처럼 전혀 compiler가 의도하지 않는 instruction set이 나올 수 있다. 여기서 위 코드를 보고, 상호 종속적인 부분이 있는지 확인하는 그래프를 그려보면 다음과 같다. 예를 들어 push ebx는 mov ebx, [ecx+0xc]와 종속적이지만 mov eax, [ecx+0x10]과는 독립적이다.</p> <p><a href="http://dandylife.net/blog/wp-content/uploads/2015/03/rop2.png"><img src="http://dandylife.net/blog/wp-content/uploads/2015/03/rop2.png" alt="rop2"/></a></p> <p>이를 이용해 보면 아래 코드 좌측은 우측과 같이 변형해도 완전히 동일하게 된다. 이 경우 초기 세 번의 push는 마지막 부분 stack에서 pop 연산을 할 때 LIFO (Last-In First-Out) 특성을 고려해 위치만 맞춰주면 된다.</p> <p><a href="http://dandylife.net/blog/wp-content/uploads/2015/03/rop3.png"><img src="http://dandylife.net/blog/wp-content/uploads/2015/03/rop3.png" alt="rop3"/></a></p> <p>마지막으로 register 재할당 부분은 바로 예제를 보자.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ORIGINAL]
.text:0700104E 8B 35 D0 88 01 07       mov     esi, dword_70188D0
.text:07001054 EB 0A                   jmp     short loc_7001060
.text:07001056                         ; ---------------------------------
.text:07001056
.text:07001056                         loc_7001056:; CODE XREF: sub_7001000+65j 
.text:07001056 8B 06                   mov     eax, [esi]
.text:07001058 8B CE                   mov     ecx, esi
.text:0700105A FF 50 08                call    dword ptr [eax+8]
.text:0700105D 8B 76 04                mov     esi, [esi+4]
.text:07001060
.text:07001060                         loc_7001060:; CODE XREF: sub_7001000+54j
.text:07001060 8B 45 EC                mov     eax, [ebp+var_14]
.text:07001063 3B F0                   cmp     esi, eax
.text:07001065 75 EF                   jnz     short loc_7001056
.text:07001067 32 C0                   xor     al, al
.text:07001069
.text:07001069                         loc_7001069:  CODE XREF: sub_7001000+4Cj
.text:07001069 E8 55 55 00 00          call    __EH_epilog3
.text:0700106E C3                      retn

[PATCHED]
.text:0700104E 8B 1D D0 88 01 07       mov     ebx, dword_70188D0
.text:07001054 EB 0A                   jmp     short loc_7001060
.text:07001056                         ; ---------------------------------
.text:07001056
.text:07001056                         loc_7001056: ; CODE XREF: sub_7001000+65j
.text:07001056 8B 03                   mov     eax, [ebx]
.text:07001058 8B CB                   mov     ecx, ebx
.text:0700105A FF 50 08                call    dword ptr [eax+8]
.text:0700105D 8B 5B 04                mov     ebx, [ebx+4]
.text:07001060
.text:07001060                         loc_7001060: ; CODE XREF: sub_7001000+54j
.text:07001060 8B 45 EC                mov     eax, [ebp-14h]
.text:07001063 3B D8                   cmp     ebx, eax
.text:07001065 75 EF                   jnz     short loc_7001056
.text:07001067 32 C0                   xor     al, al
.text:07001069
.text:07001069                         loc_7001069: ; CODE XREF: sub_7001000+4Cj
.text:07001069 E8 55 55 00 00          call    sub_70065C3
.text:0700106E C3                      retn
</code></pre></div></div> <p>이 경우 원래 esi를 전체 흐름에서 사용하고 있지 않던 ebx로 재할당했다. CPU의 입장에서 보면 한 thread에서 사용하고 있지 않은 다른 저장소를 이용한 셈이므로 전혀 문제될 것이 없다. 하지만 ROP 공격 관점에서 보면, gadget이 없어지거나 사용할 수 없게끔 흐트러지는 결과를 낳는다.</p> <table> <tbody> <tr> <td>orp는 현재 [-d</td> <td>-p</td> <td>-r</td> <td>-c] 네 가지 option을 사용할 수 있으며, 우선 -d 옵션으로 대상을 IDA Pro를 이용해 분석하는 작업을 한다. 그런 후 -r 옵션으로 randomization하면 된다. -p와 -c는 각각 profiling, coverage evaluation을 의미한다. 아래 결과는 Adobe Reader 9.3 버전에 있는 BIB.dll을 대상으로 1,737개의 명령어가 변경되었음을 알려준다.</td> </tr> </tbody> </table> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python orp.py -r BIB.dll
Orp v0.3
     found 112 level-0 functions
     found 77 level-1 functions
     found 66 level-2 functions
     found 1 level-3 functions
no more to analyze .. let's search for typed
found 66 typed and not analyzed functions
     found 66 level-4 functions
     found 14 level-5 functions
     found 1 level-6 functions
no more to analyze .. let's search for typed
found 0 typed and not analyzed functions
     classified 337 out of 1298 functions
     analyzing level-0 functions
     analyzing level-1 functions
     analyzing level-2 functions
     analyzing level-3 functions
     analyzing level-4 functions
     analyzing level-5 functions
     analyzing level-6 functions
     analyzing unclassified functions
counting the number of updated call instructions:
     total 1737, updated 1533
changed 2019 bytes of at least 18549 changeable
(not counting all possible reorderings and preservations)
</code></pre></div></div> <p>아래는 변경된 바이트를 byte 단위로 diff한 모습이다.</p> <p><a href="http://dandylife.net/blog/wp-content/uploads/2015/03/rop4.png"><img src="http://dandylife.net/blog/wp-content/uploads/2015/03/rop4.png" alt="rop4"/></a></p>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Attack &amp;amp; Defense, Cyber Warfare"/><category term="mitigation"/><category term="rop"/><category term="system security"/><summary type="html"><![CDATA[바로 이전 포스팅에서 ROP 공격을 완화시킬 수 있는 한 방안인 in-place randomization 기법을 소개했는데, 한 번 testing해 봤다. 이 논문의 저자인 Vasilis Pappas는 그 해 rop 관련 방어기법인 kbouncer를 소개해 MS의 Bluehat에서 상금 20만불을 거머쥐기도 했다. (http://www.microsoft.com/security/bluehatprize/) 여기서 사용하는 orp라는 도구 역시 Vasilis가 디자인한 상당히 강력한 ROP 방어 기법 중 하나다.]]></summary></entry><entry><title type="html">PE File Format</title><link href="https://kevinkoo001.github.io/blog/2015/pe-file-format-2/" rel="alternate" type="text/html" title="PE File Format"/><published>2015-02-16T06:46:51+00:00</published><updated>2015-02-16T06:46:51+00:00</updated><id>https://kevinkoo001.github.io/blog/2015/pe-file-format-2</id><content type="html" xml:base="https://kevinkoo001.github.io/blog/2015/pe-file-format-2/"><![CDATA[<p><a href="http://dandylife.net/blog/wp-content/uploads/2015/02/pe_format.png"><img src="http://dandylife.net/blog/wp-content/uploads/2015/02/pe_format.png" alt="pe_format"/></a></p> <p><strong>(1) IMAGE_DOS_HEADER</strong></p> <p>Note that the highlighted lines are the fields we need to focus on.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _IMAGE_DOS_HEADER {
   WORD  e_magic;      /* 00: MZ Header signature */
   WORD  e_cblp;       /* 02: Bytes on last page of file */
   WORD  e_cp;         /* 04: Pages in file */
   WORD  e_crlc;       /* 06: Relocations */
   WORD  e_cparhdr;    /* 08: Size of header in paragraphs */
   WORD  e_minalloc;   /* 0a: Minimum extra paragraphs needed */
   WORD  e_maxalloc;   /* 0c: Maximum extra paragraphs needed */
   WORD  e_ss;         /* 0e: Initial (relative) SS value */
   WORD  e_sp;         /* 10: Initial SP value */
   WORD  e_csum;       /* 12: Checksum */
   WORD  e_ip;         /* 14: Initial IP value */
   WORD  e_cs;         /* 16: Initial (relative) CS value */
   WORD  e_lfarlc;     /* 18: File address of relocation table */
   WORD  e_ovno;       /* 1a: Overlay number */
   WORD  e_res[4];     /* 1c: Reserved words */
   WORD  e_oemid;      /* 24: OEM identifier (for e_oeminfo) */
   WORD  e_oeminfo;    /* 26: OEM information; e_oemid specific */
   WORD  e_res2[10];   /* 28: Reserved words */
   DWORD e_lfanew;     /* 3c: Offset (pointer) to PE header */
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
</code></pre></div></div> <p>The following image illustrates DOS HEADER.</p> <p><img src="http://dandylife.net/blog/wp-content/uploads/2015/02/1.png" alt="1"/></p> <p><strong>(2) DOS Stub</strong></p> <p>This part is no longer using after 32 bit mode. The following image shows an example of DOS Stub.</p> <p><a href="http://dandylife.net/blog/wp-content/uploads/2015/02/2.png"><img src="http://dandylife.net/blog/wp-content/uploads/2015/02/2.png" alt="2"/></a></p> <p><strong>(3) IMAGE_NT_HEADERS (Size:0xF8)</strong></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _IMAGE_NT_HEADERS {
 DWORD Signature; /* "PE"\0\0 */       /* 0x00 */
 IMAGE_FILE_HEADER FileHeader;         /* 0x04 */
 IMAGE_OPTIONAL_HEADER32 OptionalHeader;       /* 0x18 */
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
</code></pre></div></div> <p>An example of NT Headers is as following. Note that the starting address matches the value “0x000000E0” with the one from <em>e_lfanew field</em> in DOS Header. NT Header contains both Image File Header and Image Optional Header.</p> <p><a href="http://dandylife.net/blog/wp-content/uploads/2015/02/3.png"><img src="http://dandylife.net/blog/wp-content/uploads/2015/02/3.png" alt="3"/></a></p> <p><strong>(4) IMAGE_FILE_HEADER</strong></p> <ul> <li> <p><em>Machine</em> field specifies the architecture; 0x14c means x86 and 0x8664 means x86-64.</p> </li> <li> <p><em>TimeDateStamp</em> field has Unix timestamp whose epoc is 00:00:00 UTC on Jan. 1st, 1970 at link time.</p> </li> <li> <p>SizeOfOptionalHeader field indicates the number of section headers.</p> </li> <li> <p><em>Characteristics</em> field shows the property of an executable file. See the below.</p> <p>typedef struct _IMAGE_FILE_HEADER { WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</p> <p>/* These are the settings of the Machine field. */ #define IMAGE_FILE_MACHINE_UNKNOWN 0 #define IMAGE_FILE_MACHINE_I860 0x014d #define IMAGE_FILE_MACHINE_I386 0x014c #define IMAGE_FILE_MACHINE_R3000 0x0162 #define IMAGE_FILE_MACHINE_R4000 0x0166 #define IMAGE_FILE_MACHINE_R10000 0x0168 #define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 #define IMAGE_FILE_MACHINE_ALPHA 0x0184 #define IMAGE_FILE_MACHINE_SH3 0x01a2 #define IMAGE_FILE_MACHINE_SH3DSP 0x01a3 #define IMAGE_FILE_MACHINE_SH3E 0x01a4 #define IMAGE_FILE_MACHINE_SH4 0x01a6 #define IMAGE_FILE_MACHINE_SH5 0x01a8 #define IMAGE_FILE_MACHINE_ARM 0x01c0 #define IMAGE_FILE_MACHINE_THUMB 0x01c2 #define IMAGE_FILE_MACHINE_ARMNT 0x01c4 #define IMAGE_FILE_MACHINE_ARM64 0xaa64 #define IMAGE_FILE_MACHINE_AM33 0x01d3 #define IMAGE_FILE_MACHINE_POWERPC 0x01f0 #define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1 #define IMAGE_FILE_MACHINE_IA64 0x0200 #define IMAGE_FILE_MACHINE_MIPS16 0x0266 #define IMAGE_FILE_MACHINE_ALPHA64 0x0284 #define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 #define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 #define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64 #define IMAGE_FILE_MACHINE_TRICORE 0x0520 #define IMAGE_FILE_MACHINE_CEF 0x0cef #define IMAGE_FILE_MACHINE_EBC 0x0ebc #define IMAGE_FILE_MACHINE_AMD64 0x8664 #define IMAGE_FILE_MACHINE_M32R 0x9041 #define IMAGE_FILE_MACHINE_CEE 0xc0ee</p> <p>/* These defines the meanings of the bits in the Characteristics field <em>/ #define IMAGE_FILE_RELOCS_STRIPPED 0x0001 /</em> No relocation info */ #define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002 #define IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004 #define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008 #define IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010 #define IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020 #define IMAGE_FILE_16BIT_MACHINE 0x0040 #define IMAGE_FILE_BYTES_REVERSED_LO 0x0080 #define IMAGE_FILE_32BIT_MACHINE 0x0100 #define IMAGE_FILE_DEBUG_STRIPPED 0x0200 #define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400 #define IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800 #define IMAGE_FILE_SYSTEM 0x1000 #define IMAGE_FILE_DLL 0x2000 #define IMAGE_FILE_UP_SYSTEM_ONLY 0x4000 #define IMAGE_FILE_BYTES_REVERSED_HI 0x8000</p> </li> </ul> <p><strong>(5) IMAGE_OPTIONAL_HEADER</strong></p> <p>Note that Optional header is not all optional!!</p> <ul> <li> <p>_AddressOfEntryPoint _specifies the RVA which the loader starts code execution</p> </li> <li> <p><em>SizeOfImage</em> tells the amount of contiguous memory reserved to load the binary into memory.</p> </li> <li> <p><em>SectionAlignment</em> specifies that sections should be aligned on boundaries of multiples of this value.</p> </li> <li> <p>_FileAlignment _field tells that data has to be written to a file in chucks no smaller than this value. i.e 0x200 or 512 in HDD sector size</p> </li> <li> <p><em>ImageBase</em> field specifies the preferred virtual memory address for the beginning of the binary.</p> </li> <li> <p><em>DLLCharateristics</em> field provides the loader with security options like ASLR and DEP NX memory regions. -&gt; Not limited to DLLs, IDE compiler with the /DYNAMICBASE option</p> </li> <li> <p>DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] has two fields: <em>VirtualAddress _and _Size</em></p> <p>typedef struct _IMAGE_OPTIONAL_HEADER { /* Standard fields <em>/ WORD Magic; /</em> 0x10b or 0x107 <em>/ /</em> 0x00 <em>/ BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; /</em> 0x10 <em>/ DWORD BaseOfCode; DWORD BaseOfData; /</em> NT additional fields <em>/ DWORD ImageBase; DWORD SectionAlignment; /</em> 0x20 <em>/ DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; /</em> 0x30 <em>/ WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; /</em> 0x40 <em>/ WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; /</em> 0x50 <em>/ DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; /</em> 0x60 <em>/ /</em> 0xE0 */ } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</p> <p>// Directory Entries (16 entries are pre-defined) #define IMAGE_DIRECTORY_ENTRY_EXPORT 0 /<em>Export Directory */ #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 /</em>Import Directory <em>/ #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 /</em>Resource Directory <em>/ #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 /</em>Exception Directory <em>/ #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 /</em>Security Directory <em>/ #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 /</em>Base Relocation Table <em>/ #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 /</em>Debug Directory <em>/ #define IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 /</em> (x86 usage) <em>/ #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 /</em> Architecture Specific Data <em>/ #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 /</em> RVA of GP <em>/ #define IMAGE_DIRECTORY_ENTRY_TLS 9 /</em> TLS Directory <em>/ #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 /</em> Load Configuration Directory <em>/ #define IMAGE_DIRECTORY_ENTRY_LOAD_BOUND_IMPORT 11 /</em> Bound Import Directory in headers <em>/ #define IMAGE_DIRECTORY_ENTRY_LOAD_IAT 12 /</em> Import Address Table <em>/ #define IMAGE_DIRECTORY_ENTRY_LOAD_DELAY_IMPORT 13 /</em> Delay Load Import Descriptors <em>/ #define IMAGE_DIRECTORY_ENTRY_LOAD_COM_DESCRIPTOR 14 /</em> COM Runtime descriptor */</p> </li> </ul> <p>Each directory has similar structure as following:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct _IMAGE_DATA_DIRECTORY {
 DWORD VirtualAddress;
 DWORD Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
</code></pre></div></div> <p><strong>(6) IMAGE_SECTION_HEADER (.text, .data, .rsrc, .reloc, …)</strong></p> <ul> <li> <p><em>VirtualAddress</em> specifies the RVA (Relative Virtual Address) of the section relative to <em>ImageBase.</em></p> </li> <li> <p>PointerToRawData specifies a relative offset to store the actual section data from the file .</p> </li> <li> <p><em>SizeOfRawData</em> indicates the size of memory allocation for the section. The value is Mics.VirtualSize which is rounded up to the multiple of alignment.</p> </li> <li> <p><em>PointerToRawData</em> field indicates the actual file offset from the section.</p> </li> <li> <p>See the below for a <em>characteristics</em> field.</p> <h1 id="define-image_sizeof_short_name-8">define IMAGE_SIZEOF_SHORT_NAME 8</h1> <p>typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</p> </li> </ul> <p><a href="http://dandylife.net/blog/wp-content/uploads/2015/02/4.png"><img src="http://dandylife.net/blog/wp-content/uploads/2015/02/4.png" alt="4"/></a></p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/* These defines are for the Characteristics bitfield. */
/* #define IMAGE_SCN_TYPE_REG                   0x00000000 - Reserved */
/* #define IMAGE_SCN_TYPE_DSECT                 0x00000001 - Reserved */
/* #define IMAGE_SCN_TYPE_NOLOAD                0x00000002 - Reserved */
/* #define IMAGE_SCN_TYPE_GROUP                 0x00000004 - Reserved */
#define IMAGE_SCN_TYPE_NO_PAD                0x00000008 /* Reserved */
/* #define IMAGE_SCN_TYPE_COPY                  0x00000010 - Reserved */

#define IMAGE_SCN_CNT_CODE                      0x00000020
#define IMAGE_SCN_CNT_INITIALIZED_DATA          0x00000040
#define IMAGE_SCN_CNT_UNINITIALIZED_DATA        0x00000080

#define IMAGE_SCN_LNK_OTHER                     0x00000100
#define IMAGE_SCN_LNK_INFO                      0x00000200
/* #define      IMAGE_SCN_TYPE_OVER             0x00000400 - Reserved */
#define IMAGE_SCN_LNK_REMOVE                    0x00000800
#define IMAGE_SCN_LNK_COMDAT                    0x00001000

/*                                              0x00002000 - Reserved */
/* #define IMAGE_SCN_MEM_PROTECTED              0x00004000 - Obsolete */
#define IMAGE_SCN_MEM_FARDATA                   0x00008000

/* #define IMAGE_SCN_MEM_SYSHEAP                0x00010000 - Obsolete */
#define IMAGE_SCN_MEM_PURGEABLE                 0x00020000
#define IMAGE_SCN_MEM_16BIT                     0x00020000
#define IMAGE_SCN_MEM_LOCKED                    0x00040000
#define IMAGE_SCN_MEM_PRELOAD                   0x00080000

#define IMAGE_SCN_ALIGN_1BYTES                  0x00100000
#define IMAGE_SCN_ALIGN_2BYTES                  0x00200000
#define IMAGE_SCN_ALIGN_4BYTES                  0x00300000
#define IMAGE_SCN_ALIGN_8BYTES                  0x00400000
#define IMAGE_SCN_ALIGN_16BYTES                 0x00500000  /* Default */
#define IMAGE_SCN_ALIGN_32BYTES                 0x00600000
#define IMAGE_SCN_ALIGN_64BYTES                 0x00700000
#define IMAGE_SCN_ALIGN_128BYTES                0x00800000
#define IMAGE_SCN_ALIGN_256BYTES                0x00900000
#define IMAGE_SCN_ALIGN_512BYTES                0x00A00000
#define IMAGE_SCN_ALIGN_1024BYTES               0x00B00000
#define IMAGE_SCN_ALIGN_2048BYTES               0x00C00000
#define IMAGE_SCN_ALIGN_4096BYTES               0x00D00000
#define IMAGE_SCN_ALIGN_8192BYTES               0x00E00000
/*                                              0x00F00000 - Unused */
#define IMAGE_SCN_ALIGN_MASK                    0x00F00000
#define IMAGE_SCN_LNK_NRELOC_OVFL               0x01000000
#define IMAGE_SCN_MEM_DISCARDABLE               0x02000000
#define IMAGE_SCN_MEM_NOT_CACHED                0x04000000
#define IMAGE_SCN_MEM_NOT_PAGED                 0x08000000
#define IMAGE_SCN_MEM_SHARED                    0x10000000
#define IMAGE_SCN_MEM_EXECUTE                   0x20000000
#define IMAGE_SCN_MEM_READ                      0x40000000
#define IMAGE_SCN_MEM_WRITE                     0x80000000
</code></pre></div></div> <p>Here are several good resources to explain PE format.</p> <ul> <li> <p><a href="http://www.openwatcom.org/ftp/devel/docs/pecoff.pdf">Microsoft Portable Executable and Common Object File Format Specification</a></p> </li> <li> <p><a href="http://www.woodmann.com/collaborative/knowledge/images/Bin_Portable_Executable_File_Format_%E2%80%93_A_Reverse_Engineer_View_2012-1-31_16.43_CBM_1_2_2006_Goppit_PE_Format_Reverse_Engineer_View.pdf">Bin Portable Executable File Format - A Reverse Engineer View</a></p> </li> <li> <p><a href="http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf">PE Format (OpenRCE.org)</a></p> </li> </ul>]]></content><author><name>kevinkoo001@gmail.com</name></author><category term="Attack &amp;amp; Defense, Cyber Warfare"/><summary type="html"><![CDATA[]]></summary></entry></feed>