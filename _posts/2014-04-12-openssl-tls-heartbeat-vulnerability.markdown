---
author: kevinkoo001@gmail.com
comments: true
date: 2014-04-12 21:34:24+00:00
layout: post
link: http://dandylife.net/blog/archives/231
slug: openssl-tls-heartbeat-vulnerability
title: OpenSSL TLS Heartbeat Vulnerability
wordpress_id: 231
categories:
- Attack &amp; Defense, Cyber Warfare
tags:
- Heartbeat
- OpenSSL
---



**A. Summary[![heartbleed](http://newt.arvixe.com/~mrkoo001/blog/wp-content/uploads/2014/04/heartbleed.png)](http://newt.arvixe.com/~mrkoo001/blog/wp-content/uploads/2014/04/heartbleed.png)**
[Affected] OpenSSL 1.0.1 through 1.0.1f, OpenSSL 1.0.2-beta
[Overview] A vulnerability in OpenSSL could allow a remote adversary to expose sensitive data, up to 64K chunk in memory
[Impact] High

**B. CVE/PoC Code**
[CVE-2014-0160](http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160)
[US CERT ALERTS](https://www.us-cert.gov/ncas/alerts/TA14-098A)
[OpenSSL TLS Heartbeat Extension - Memory Disclosure](http://www.exploit-db.com/exploits/32745/)

**C. News and Articles**
[Millions of Android Devices Vulnerable to Heartbleed Bug](http://www.bloomberg.com/news/2014-04-11/millions-of-android-devices-vulnerable-to-heartbleed-bug.html)
[Heartbleed developer explains OpenSSL mistake that put Web at risk](http://arstechnica.com/information-technology/2014/04/heartbleed-developer-explains-openssl-mistake-that-put-web-at-risk/)
[xkcd](http://xkcd.com/1354/)

**D. Impact**
[The Heartbleed Hit List: The Passwords You Need to Change Right Now](http://mashable.com/2014/04/09/heartbleed-bug-websites-affected/)
[The heartbleed-masstest results for TOP 1000 sites](https://github.com/musalbas/heartbleed-masstest/blob/master/top1000.txt)

**E. How it works**
[Diagnosis of the OpenSSL Heartbleed Bug](http://blog.existentialize.com/diagnosis-of-the-openssl-heartbleed-bug.html)
[How Heartbleed Works: The Code Behind the Internet's Security Nightmare](http://gizmodo.com/how-heartbleed-works-the-code-behind-the-internets-se-1561341209)

**F. Fixed/Update**
[Adding heartbeat extension bounds check](http://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=96db9023b881d7cd9f379b0c154650d6c108e9a3)

The following is the fixed part to check the validation from line 17-19 before memcpy(bp, pl, payload).Â ([http://git.openssl.org/gitweb/?p=openssl.git;a=blob_plain;f=ssl/d1_both.c](http://git.openssl.org/gitweb/?p=openssl.git;a=blob_plain;f=ssl/d1_both.c))

    
    int dtls1_process_heartbeat(SSL *s)
    	{
    	unsigned char *p = &s->s3->rrec.data[0], *pl;
    	unsigned short hbtype;
    	unsigned int payload;
    	unsigned int padding = 16; /* Use minimum padding */
    
    	if (s->msg_callback)
    		s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
    			&s->s3->rrec.data[0], s->s3->rrec.length,
    			s, s->msg_callback_arg);
    
    	/* Read type and payload length first */
    	if (1 + 2 + 16 > s->s3->rrec.length)
    		return 0; /* silently discard */
    	hbtype = *p++;
    	n2s(p, payload);
    	if (1 + 2 + payload + 16 > s->s3->rrec.length)
    		return 0; /* silently discard per RFC 6520 sec. 4 */
    	pl = p;
    
    	if (hbtype == TLS1_HB_REQUEST)
    		{
    		unsigned char *buffer, *bp;
    		unsigned int write_length = 1 /* heartbeat type */ +
    					    2 /* heartbeat length */ +
    					    payload + padding;
    		int r;
    
    		if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
    			return 0;
    
    		/* Allocate memory for the response, size is 1 byte
    		 * message type, plus 2 bytes payload length, plus
    		 * payload, plus padding
    		 */
    		buffer = OPENSSL_malloc(write_length);
    		bp = buffer;
    
    		/* Enter response type, length and copy payload */
    		*bp++ = TLS1_HB_RESPONSE;
    		s2n(payload, bp);
    		memcpy(bp, pl, payload);
    		bp += payload;
    		/* Random padding */
    		RAND_pseudo_bytes(bp, padding);
    
    		r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
    
    		if (r >= 0 && s->msg_callback)
    			s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
    				buffer, write_length,
    				s, s->msg_callback_arg);
    
    		OPENSSL_free(buffer);
    
    		if (r < 0)
    			return r;
    		}
    	else if (hbtype == TLS1_HB_RESPONSE)
    		{
    		unsigned int seq;
    
    		/* We only send sequence numbers (2 bytes unsigned int),
    		 * and 16 random bytes, so we just try to read the
    		 * sequence number */
    		n2s(pl, seq);
    
    		if (payload == 18 && seq == s->tlsext_hb_seq)
    			{
    			dtls1_stop_timer(s);
    			s->tlsext_hb_seq++;
    			s->tlsext_hb_pending = 0;
    			}
    		}
    
    	return 0;
    	}
